{"categories":[{"title":"computer networking","uri":"https://hanin97.cn/categories/computer-networking/"},{"title":"cpp","uri":"https://hanin97.cn/categories/cpp/"},{"title":"operating system","uri":"https://hanin97.cn/categories/operating-system/"},{"title":"papers reading","uri":"https://hanin97.cn/categories/papers-reading/"},{"title":"Project","uri":"https://hanin97.cn/categories/project/"}],"posts":[{"content":"Codes for $S^2Net$ for prostate ","id":0,"section":"posts","summary":"Codes for $S^2Net$ for prostate ","tags":[""],"title":"S2NetForProstate","uri":"https://hanin97.cn/2021/04/s2netforprostate/","year":"2021"},{"content":"","id":1,"section":"posts","summary":"","tags":null,"title":"计算机网络--1 概述","uri":"https://hanin97.cn/2021/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C-1%E6%A6%82%E8%BF%B0/","year":"2021"},{"content":"操作系统之进程与线程   L8 CPU管理的直观想法 2021-03-19 管理CPU IO指令执行特别慢，比计算语句为10^6:1，如果计算指令与IO指令顺序执行，CPU利用率特别低，要提高CPU的利用率，多道程序交替执行 并发：多道程序放在内存中，CPU交替执行，切过去，切回来（改PC，即IP） 怎么实现这种交替执行呢？\n 记录返回地址和继续执行需要的数据  进程：进行中的程序\n  L9 多进程图像（Multiple Processes） 2021-03-20\n用户创建多个进程，操作系统使用PCB（Process Control Block）记录这些进程，按合理的次序推进 多进程图像从启动开始到关机结束 main中的fork()创建了第一个进程，init执行了shell（Windows桌面） if(!fork) {init();} shell再启动其他进程\nint main(int argc, char* argv[]) { while(1) { scanf(\u0026quot;%s\u0026quot;, cmd); if(!fork()) {exec(cmd);} wait(); } }  多进程的组织：PCB+状态+队列 交替：队列操作（设计到怎么取下一个进程）+调度+切换\n// 要使用汇编来精细控制 switch_to(pCur,pNew) { pCur.ax = CPU.ax; pCur.bx = CPU.bx; ... pCur.cs = CPU.cs; pCur.retpc = CPU.pc; CPU.ax = pNew.ax; CPU.bx = pNew.bx; ... CPU.cs = pNew.cs; CPU.retpc = pNew.pc; }  如何解决多进程间的相互影响？多进程的地址空间分离（内存管理，映射表） 如何解决多进程间的相互合作？进程同步（锁！切换条件，检查锁，上锁，开锁）\nfork()：在现有进程中创建子进程，子进程是父进程的副本，它将获得父进程数据空间、堆栈等资源的副本，后面需要使用时，再分离修改。\n  L10 用户级线程（User Threads）yield 2021-03-20 进程 = 资源 + 指令执行序列 如果能将资源和指令执行分开，切换指令而资源不变，岂不美哉？==\u0026gt;线程（映射表不变而PC指针变） 线程和进程肯定都有自己适用的地方 线程： 概念：多个执行序列 + 一个地址空间 适用场景：多个线程配合完成一个任务，不需要地址隔离 实现：pthread_create创建，yield切换 存在的问题：如果两个线程共用一个栈，那么切换会出问题，线程内部函数切换和线程间切换就乱套了 解决：当然是隔离栈啦\n ```cpp // 寄存器esp指向当前栈的指针 void Yield() { TCB2.esp = esp; esp = TCB1.esp; jmp xxx; // 这句话应该去掉，不然后面的}无法执行，少弹(ret)了一次栈 } // 创建TCB，并和栈关联 void ThreadCreate(A) { TCB *tcb = malloc(); *stack = malloc(); *stack = A; tcb.esp = stack; } ``` 缺点：如果一个线程进入内核后发生阻塞（如访问网卡IO，访问硬件需要通过内核），那么内核将会切换到其他进程，看不到这个线程后的其他线程，但是核心级线程是在内核中，并发性更好    L11 核心级线程（Kernel Threads）schedule 内核级线程才能真正发挥多核CPU的功能，因为用户级线程无法对硬件进行分配 多进程也不能，因为多核CPU的Cache和MMU是共享的\n从用户级到内核级：两个栈到两套栈（每个都有用户栈和内核栈），内核级线程比用户级多了一步内核栈切换 那么内核栈在哪呢？中断进入（INT）内核时自动启用内核栈（硬件实现），IRET退出\n  L12 核心级线程实现实例 2021-03-22 没有实际写代码，对汇编和C要求很高  L13 操作系统的那棵树 2021-03-23 梳理怎样从简单的顺序执行到用户态多进程再到内核态多进程\n  L14 CPU调度策略 根据任务需求综合考虑：响应时间，周转时间，系统内耗（切换次数） 前台任务、后台任务；IO约束型、CPU约束型 常见的调度算法：\n First Come, First Served (FCFS)  短作业优先（SJF）那怎么知道谁长谁短呢？周转时间最短（后台任务），但是响应时间得不到保证 轮转（RR）按时间片轮转调度 响应时间可以得到保证（前台任务），通过时间片大小控制，但是要控制进程数N 优先级调度 前台任务优先级大于后台任务，但只用优先级调度会造成后台任务饥饿 如果后台任务优先级动态升高，前台的响应时间又得不到保证 如果前后台都是用时间片，那后台任务的SJF又得不到体现    L15 一个实际的schedule函数 2021-03-23\nvoid Schedule(void) { while(1) { c = -1; next = 0; i = NR_TASKS; p = \u0026amp;task[NR_TASKS]; // 这句话没明白；明白了（数组的末尾存放PCB） while(--i) // 下面的p没变吧；PPT中的程序少了 { if(!*--p) continue; // counter既有优先级的作用，又有时间片的作用 if((*p)-\u0026gt;state==TASK_RUNNING\u0026amp;\u0026amp;(*p)-\u0026gt;counter\u0026gt;c) c = (*p)-\u0026gt;counter, next = i; // 找到就绪态counter最大的进程 } if(c) break; for(p=\u0026amp;LAST_TASK;p\u0026gt;\u0026amp;FIRST_TASK;--p) { if(*p) // 保证进入IO的进程再出来后优先级变大 (*p)-\u0026gt;counter = ((*p)-\u0026gt;counter\u0026gt;\u0026gt;1) + (*p)-\u0026gt;priority; } } switch_to(next); } // counter时间片的作用 void do_timer(...) { if (--(current-\u0026gt;counter)\u0026gt;0) return; current-\u0026gt;counter = 0; // 到点就执行 schedule(); }    L16 进程同步与信号量 2021-03-24 场景：进程合作，多进程共同完成一个任务 只发信号不能处理多对多（多个生产者消费者）的问题，需要使用信号量 生产进程，消耗进程\n  L17 对信号量的临界区保护 2021-03-25 问题： 不同进程共同修改（调度）信号量时可能会出错，导致信号量的含义不对。 解决方案： 上锁保护，修改信号量的代码放在临界区（一次只允许一个进程进入的该进程的那段代码） 临界区代码的保护原则：\n 互斥进入； 有空让进； 有限等待  第一种：对称法容易造成卡死，非对称=轮转+标记（Peterson算法） 两个进程：Peterson算法 多进程：面包店算法（复杂）\n第二种：硬件阻止另一个进程进入临界区，也就是阻止调度=\u0026gt;关中断（cli，sti），但是多核时不好使，只能控制一个CPU\n第三种：硬件原子指令   L18 信号量的代码实现 2021-03-26 很隐蔽的队列：编译的时候，tmp放在当前进程的内核栈中，那么task_struct就能找到tmp，tmp又指向前一个task_struct   L19 死锁处理 2021-03-26 多进程环路等待 成因（比如信号量临界区的上锁和解锁间加入了别的信号量）：\n 互斥使用； 不可抢占； 请求和保持； 循环等待。  解决方案：\n 死锁预防（资源浪费）； 死锁避免，判断系统中的所有进程是否存在一个可完成的执行序列，即安全状态（银行家算法，时间复杂度高），如果可能产生死锁，则拒绝此次资源申请； 死锁检测+恢复，不每次申请的时候都执行银行家算法，转而定时检测或者发现资源利用率低的时候检测（但发现问题时想回滚挺麻烦）； 死锁忽略（因为最简单，而且出现死锁的概率小，并且重启可以解决，都采用这个方法我笑了）    操作系统之内存管理 ","id":2,"section":"posts","summary":"操作系统之进程与线程 L8 CPU管理的直观想法 2021-03-19 管理CPU IO指令执行特别慢，比计算语句为10^6:1，如果计算指令与IO指令顺序执行，CPU利","tags":null,"title":"操作系统  进程与线程","uri":"https://hanin97.cn/2021/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E8%BF%9B%E7%A8%8B%E4%B8%8E%E7%BA%BF%E7%A8%8B/","year":"2021"},{"content":"操作系统之基础 打开电源CS=0xFFFF, IP=0x0000 寻址0xFFFF0（ROM BIOS映射区） 检查RAM，键盘，显示器，软硬磁盘 将磁盘0磁道0扇区（引导扇区512字节）读入0x7C00处 设置CS=0x07C0, IP=0x0000\n执行bootsect （.s） 将引导0x7C00移动到0x9000:0x0000处 载入setup模块（4个扇区）到0x9000:0x0200处（int 0x13） 获取磁盘数 读光标\u0026ndash;显示Loading system 读入system模块（0x1000+0x8000[SYSSIZE, 编译操作系统时设置]） jmpi 0, SETUPSEG\n执行setup 取出光标位置（0x90000），扩展内存大小（0x90002） 将system模块移到0地址（所以上面要先将引导扇区移到0x9000:0x0000处） 进入保护模式并跳转至0地址（mov ax, #0x0001 mov cr0, ax jmpi 0, 8） [cr0寄存器最后一位设为1时，进入保护模式，寻址方式发生改变，使用地址翻译（从GDT全局描述符表中选择基址），0时为实模式]\n执行system 第一部分代码为head.s（32位汇编代码），利用压栈调用C函数（main.c） 进入main函数（各种初始化） 进入main函数后永不退出，操作系统一直运行\n  L1 什么是操作系统 2021-03-17\n  L2 开始揭开钢琴的盖子 2021-03-17\n  L3 操作系统启动 2021-03-17\n  L4 操作系统接口 2021-03-18 系统接口就是提供一些函数来完成系统调用，实现应用程序和操作系统的交流。POSIX标准\n  L5 系统调用的实现 2021-03-18 既然应用程序和内核都在内存中，为什么应用程序不能直接访问内存，获取想要的东西，而要通过系统调用？那当然啦，不然岂不是什么都能轻易被人拿去了，密码随便就没了 那怎么禁止这种乱用（jmp，mov）内核呢？ 使用硬件实现隔离（内核态，用户态），目标特权级（DPL），当前特权级（CPL，CS的最后两位），数字越小，特权越大 硬件也提供了主动进入内核的方法，让系统调用可以进入内核执行，int 0x80中断指令，将DPL设为3，进入内核后，CPL置为0 应用程序\u0026ndash;\u0026gt;库函数\u0026ndash;\u0026gt;系统调用（内嵌汇编，包含int指令，根据编号执行相应指令） int 0x80:\nvoid sched_init(void) { set_system_gate(0x80, \u0026amp;system_call)}  怎么添加系统调用呢？ 修改kernel/system_calls.s中的系统调用总数nr_system_calls， 在include/linux/sys.h中的sys_call_table添加对应的系统调用函数 新增who.c文件，里面编写sys_iam和sys_whoami，并修改Makefile文件，将who.c添加到内核中 在/usr/include/unistd.h中添加__NR_xxx xx，然后编写iam.c和whoami.c 编译内核，gcc编译iam.c和whoami.c\n  L6 操作系统历史 IBSYS批处理\u0026ndash;\u0026gt;OS360多道程序（多进程，作业之间切换调度）\u0026ndash;\u0026gt;MULTICS分时系统（多人）\u0026ndash;\u0026gt;UNIX\u0026ndash;\u0026gt;Linux\n多进程图谱（CPU、内存）文件操作（IO、磁盘、文件）  ","id":3,"section":"posts","summary":"操作系统之基础 打开电源CS=0xFFFF, IP=0x0000 寻址0xFFFF0（ROM BIOS映射区） 检查RAM，键盘，显示器，软硬磁盘 将磁盘0磁道0扇区（","tags":null,"title":"操作系统--基础","uri":"https://hanin97.cn/2021/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%9F%BA%E7%A1%80/","year":"2021"},{"content":"@TOC\n1 内存管理 1.1 内存使用与分段 时间：2021-03-28\n场景：汇编中，call 40这条指令表明要跳到40这个地址（逻辑地址、相对地址）执行，那么把程序载入到内存中时，物理内存的40位置一定要存放对应的程序，如果不对内存进行分段的话，这显然不切实际，因为40这个地址可能存放了别的程序（事实上，0开始的位置存放的是操作系统），所以，程序在载入内存时应当找到一段空闲内存，并修改相应的逻辑地址为物理地址（==重定位==）。\n重定位也有两种方式：\n 编译时（硬系统，如一些嵌入式的系统，效率高，但不灵活） 载入时（灵活通过，==但目前来讲，程序载入进内存就不能移动了==）  怎么才能让载入内存的程序实现移动呢？ ==swap==：如果进程发生阻塞，那把它放在内存中有点浪费内存，这时候将该进程睡眠，换出到磁盘（已经重定位过了物理地址），想执行的时候再换入，那么问题来了，怎么保证它换入时的物理内存地址和原来一样呢？==运行时重定位（地址翻译）== base+offset\nbase保存在哪呢？==PCB====\u0026gt;==基址寄存器==\n还有个问题：如果找不到一段足够大的空闲内存放程序怎么办呢？ 将程序分段，每个段有各自的特点、用途，如代码段（只读）、数据段（可写），每个段都是从0开始编址（用户可独立考虑每个段[==分治==]） 这样就可以将一个程序的每个段分别放入内存，==段号+段内偏移== 这时候PCB里要存放每个段的基址（进程段表LDT，和操作系统对应的段表GDT同理）\n1.2 内存分区与分页（Memory Partition and Paging） 时间：2021-03-29\n程序进入内存的步骤： 1. 程序分段 2. 在内存中找出空闲区域 3. 将程序从磁盘中读到内存\n为什么要分区？ 由上一小节很容易引出内存分区，因为要看哪些部分是空闲的，大小为多少\n怎么分区呢？ 固定分区与可变分区\n可变分区的管理：请求分配，释放内存，再次申请（涉及到分配哪块空闲的） 分配哪块呢？首选适配（第一个，快），最佳适配（大小最合适，O(n)），最差适配（每个段均匀） 实际的系统的物理内存并不使用内存分区，而是内存分页为什么要分页？ 解决内存分区导致的内存效率问题，比如内存碎片，需要将空闲分区合并（内存紧缩），但执行该操作的时候CPU不能干别的。\n怎么分页？ 将内存分成，比如每4K一页，针对每个段内存请求，将段打散，系统一页一页地分配给这个段，（那重定位就变得复杂点，得知道它想跳转的地方被分到了哪个页，地址//页大小（根据这个找到页框的物理地址）+地址%页大小），需要用到页表（cr3），==MMU会自动计算==\n1.3 多级页表和快表 时间：2021-04-01\n之前的分页方法有什么问题？ 为了提高内存的空间利用率，页应该小，但是页小了页表就大了\n怎么解决？ 尝试1：分配给进程中的逻辑页中，有的逻辑页用不到，（要问为什么用不到还要分配给它的话，考虑重定位时的逻辑页总数：地址//页大小 + 1），那就只保留用到的逻辑页的页表项 问题1：这时的页表不连续，查找起来费时，顺序查找\u0026ndash;\u0026gt;折半查找，但这也费时，降低运行速度，页号连续的话查找就很快，怎么结合这两个呢？==多级页表就来了==\n尝试2：页目录表+页表（类比书的目录） 可以，但访问内存的次数变多，时间上更奢侈\n尝试3：快表（TLB，相联快速存储，是寄存器） 快表中存放最近使用的页表项，找不到的话再到多级页表中找 要让快表好使，它的命中率一定要高，所以快表越大越好（但它贵呀，一般64~1024）；同时，置换的算法也很重要 1.4 段页结合的实际内存管理 程序（分段）\u0026ndash;\u0026gt;虚拟内存（地址空间，段-\u0026gt;页）\u0026ndash;\u0026gt;物理内存（分页） 逻辑地址\u0026ndash;\u0026gt;虚拟地址\u0026ndash;\u0026gt;物理地址 段面向用户，页面向硬件 虚拟内存不用管理吗？还是说浪费了也没事，有碎片就有碎片，反正不贵\n段页式内存下程序如何载入内存？ 1. 在虚拟内存中分配段 2. 将程序对应段放到虚拟内存对应段； 3. 将虚拟内存的段分页放到物理内存； 4. 建立页表； 5. 使用。  2 虚拟内存 使用换入换出实现虚拟内存。\n2.1 请求调页与内存换入（Swap in） 2021-04-06 物理内存小于虚拟内存，虚拟内存比较规整，就算物理内存没那么大，虚拟内存也能让用户感觉可以使用那么大，不用因为物理内存的大小而头疼，那么就使用换入换出实现“大内存”，用到程序的哪段就把这段从硬盘换入到物理内存。\n2.2 内存换出（Swap out） 2021-04-07 还记得请求调页时候的get_free_page吗？而内存是有限的，并不能总是获得新的页，需要选择一页淘汰，换出到磁盘，那怎么选择呢？用缺页次数来评价方案的好坏。\n FIFO，刚换出去又要换进来的话，就很麻烦 MIN，选最远将使用的页淘汰，是最优方案，但是要知道将来发生的事 LRU（Least recently used），用过去的历史预测将来，选最近最长一段时间没有使用的页淘汰  LRU怎么实现呢？ 时间戳（time stamp） 每页维护一个时间戳，记录该页在第几个时刻使用到了。（每执行一条指令，都要维护这个时间戳）\n页码栈 每执行一条指令，都要更新栈\nLRU近似实现SCR[又叫Clock Algorithm]（因为准确实现太奢侈） 将时间计数变为是和否，每页加1个引用位R，每次访问一页时，硬件自动设置该位（就不用软件维护时间戳了，直接MMU），选择淘汰页：扫描该位，是1时清0，并继续扫描，是0时淘汰。\n但如果缺页很少的话，几乎所有的R都为1（因为只有缺页时才会将0变为1），那需要换页的时候，指针会循环一遍，把所有的1变为0，然后换掉第一次指向的页，SCR退化为FIFO。 原因：记录了太长的历史信息 怎么办：定时清除R位（再来一个快的扫描指针），确保“最近”\n给进程分配多少页框（frame）呢？ 求工作集，覆盖局部。 与页框分配有关的问题：系统颠簸 ","id":4,"section":"posts","summary":"@TOC 1 内存管理 1.1 内存使用与分段 时间：2021-03-28 场景：汇编中，call 40这条指令表明要跳到40这个地址（逻辑地址、相对地址）执行，那","tags":null,"title":"操作系统--内存管理","uri":"https://hanin97.cn/2021/04/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F-%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/","year":"2021"},{"content":"Feature-driven Local Cell Graph (FLocK): New Computational Pathology-based Descriptors for Prognosis of Lung Cancer and HPV Status of Oropharyngeal Cancers 🌈个人总结：构图的时候并不直接使用空间邻近关系，而是使用特征（包含坐标）欧氏距离，但又加了点看起来更厉害的东西，并不直接计算特征间的距离，而是使用mean-shift聚类。基于构建出的图，计算了一些特征，并在多个任务上验证特征的有效性。\n背景 不同癌症亚型的细胞核的局部空间排列有一定的预后价值，但现有的的cell graph只考虑了细胞核的空间关系，并没有区分细胞类型\n构建方法  细胞核分割、形态特征（11维）提取； 在形态特征空间构建FLocK 假设一张图像中的细胞核数量为$N$，每个细胞核在$d$维欧式空间$R^d$有一个对应的特征向量，使用特征向量集$X=x_1, x_2, \u0026hellip;, x_N, x_n∈R^d$来表示一张图像，使用mean-shift聚类来为每个特征向量（细胞核）找到一个mode。 注意：特征向量中添加了2维坐标信息 基于构建的FLocK，计算FLocK特征  构建效果 ","id":5,"section":"posts","summary":"Feature-driven Local Cell Graph (FLocK): New Computational Pathology-based Descriptors for Prognosis of Lung Cancer and HPV Status of Oropharyngeal Cancers 🌈个人总结：构图的时候并不直接使用空间邻近关系，而是使用特征（包含坐标）欧氏距离，但又加了点看起来更","tags":["Computational pathology"],"title":"Feature-driven Local Cell Graph (FLocK): New Computational Pathology-based Descriptors for Prognosis of Lung Cancer and HPV Status of Oropharyngeal Cancers","uri":"https://hanin97.cn/2021/01/flock-lucheng/","year":"2021"},{"content":"Predicting survival from colorectal cancer histology slides using deep learning: A retrospective multicenter study ","id":6,"section":"posts","summary":"Predicting survival from colorectal cancer histology slides using deep learning: A retrospective multicenter study ","tags":["Computational pathology","Colorectal cancer"],"title":"Predicting survival from colorectal cancer histology slides using deep learning: A retrospective multicenter study","uri":"https://hanin97.cn/2021/01/predicting-survival-from-colorectal-cancer-histology-slides-using-deep-learning-a-retrospective-multicenter-study/","year":"2021"},{"content":"An Artificial Intelligence–based Support Tool for Automation and Standardisation of Gleason Grading in Prostate Biopsies 贡献  两阶段训练 定量对比模型在不同扫描仪上的结果 SPSS  1. 数据 穿刺图像，其中训练集图像使用徕卡Aperio CS2扫描仪扫描，测试集图像使用两种不同的扫描仪（徕卡Aperio CS2，滨松Hammamatsu S60）扫描，来测试模型的泛化能力。\n2. 训练方法 没有介绍使用了什么网络，也没有说是语义分割还是图像块分类，看起来是语义分割，但也没具体讲实施过程。 现在队列一上训练，然后使用队列二继续训练，这和直接放在一起训练区别很大吗？\n3. 实验 3.1 癌区域比例 对比算法、医生1-第一年、医生1-第二年、医生2、算法-另一种扫描仪。 3.2 Cohen\u0026rsquo;s kappa GG and Cancer v.s. Benign 3.3 Agreement index 自定义 ","id":7,"section":"posts","summary":"An Artificial Intelligence–based Support Tool for Automation and Standardisation of Gleason Grading in Prostate Biopsies 贡献 两阶段训练 定量对比模型在不同扫描仪上的结果 SPSS 1. 数据 穿刺图像，其中训练集图","tags":["computational pathology","prostate cancer"],"title":"An Artificial Intelligence–based Support Tool for Automation and Standardisation of Gleason Grading in Prostate Biopsies","uri":"https://hanin97.cn/2020/12/an-artificial-intelligencebased-support-tool-for-automation-and-standardisation-of-gleason-grading-in-prostate-biopsies/","year":"2020"},{"content":"第16章 String类和标准模板库  标准C++ string类 模板auto_prt, unique_ptr, shared_ptr\u0026ndash;智能指针 标准模板库（STL）\u0026ndash;泛型编程 容器类 迭代器 函数对象（functor） STL算法 模板initializer_list  16.1 string类 16.1.1 构造字符串 16.1.2 string类输入 C-风格字符串\nchar info[100];\rcin \u0026gt;\u0026gt; info;\rcin.getline(info, 100); // discard \\n\rcin.get(info, 100); // leave \\n in queue\r string对象\nstring stuff;\rcin \u0026gt;\u0026gt; stuff;\r- 不断读取，直到遇到使isspace()为true的空白字符并将其留在输入队列中\rgetline(cin, stuff);\r 两个版本的getline()都有一个可选参数，用于指定使用哪个字符来确定输入的边界；\ncin.getline(info, 100, ':');\rgetline(info, ':'); // 自动调整目标string对象的大小\r- 到达文件尾，设置输入流的eofbit，fail()和eof()都将返回true\r- 遇到分解字符（默认为\\n）\r- 读取的字符数达到最大允许值，设置输入流的failbit，fail()返回true\r 16.1.3 使用字符串  6个关系运算符 长度，size(), length() 搜索，find(), rfind(), find_first_of(), find_last_of(), find_first_not_of(), find_last_not_of() size_type find(const string \u0026amp; str, size_type pos = 0) const\rsize_type find(const char * s, size_type pos = 0) const\rsize_type find(const char * s, size_type pos = 0, size_type n)\rsize_type find(char ch, size_type pos = 0) const\r  删除 替换 插入 当前分配给字符串的内存块的大小，capacity() 请求内存块的最小长度，reserve() 指向C-风格字符串的指针，c_str()  16.2 智能指针模板类 思想：定义类似指针的对象，当智能指针过期时，其析构函数将使用delete来释放内存。 有：auto_ptr, unique_ptr, shared_ptr，后两个是C++11的，摒弃了第一个，因为auto_ptr可能会出现所有权丢失的问题：当使用auto_ptr指向已有auto_ptr时，原来的所有权就会丢失。\n#include \u0026lt;memory\u0026gt;\rvoid remodel(std::string \u0026amp; str)\r{\rstd::auto_prt\u0026lt;std::string\u0026gt; ps (new std::string(str))\rif (weird_thing())\rthrow exception();\rstr = *ps;\rreturn;\r}\r// 所有权丢失，好处：防止删除一个对象两次，坏处：无法再使用p1\rauto_ptr\u0026lt;string\u0026gt; p1 (new string(\u0026quot;auto\u0026quot;));\rauto_ptr\u0026lt;string\u0026gt; p2;\rp2 = p1;\r// 当把auto_ptr换成shared_ptr时，不会丢失所有权，而是将引用次数加1\r// 当把auto_ptr换成unique_ptr时，p2 = p1将非法\r 16.3 标准模板库 16.3.1 模板类vector 容器、迭代器\nvector\u0026lt;double\u0026gt; scores;\rvector\u0026lt;double\u0026gt;::iterator pd;\r// auto pd = scores.begin(); 更简洁\rpd = scores.begin();\r*pd = 22.3;\r++pd;\rfor (pd = scores.begin(); pd != scores.end(); pd++)\rcout \u0026lt;\u0026lt; *pd \u0026lt;\u0026lt; endl;\r// 一些方法\rpush_back(): 将元素添加到元素末尾\rerase(): 删除矢量中给定区间的元素，左闭右开\rinsert(): 向一个容器的某个位置插入另一个容易对象的某个区间元素\rvector\u0026lt;int\u0026gt; old_v;\rvector\u0026lt;int\u0026gt; new_v;\rold_v.insert(old_v.begin(), new_v.begin() + 1, new_v.end());\r STL函数\nfor_each(): 将被指向的函数应用于容器区间中的各个元素，很像python的map呀\rrandom_shuffle(): 随机排列容器区间中的元素\rsort(): 两个版本\r一个默认使用为存储在容器中的类型元素定义的\u0026lt;运算符，升序\r如果容器是用户定义的，则需要提供成员或非成员函数operator\u0026lt;()\r另一个版本接受三个参数，前两个同上，为区间，第三个为自定义的排序规则函数名称，返回值为bool\r 16.3.2 基于范围的for循环（C++11） double prices[3] = {4.55, 234.3, 23.3};\rfor (double x : prices)\r// 括号内的代码声明一个类型与容器存储的内容相同的变量\rcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl;\rfor_each(books.begin(), bookd.end(), ShowReview);\r类似于\rfor (auto x : books) ShowReview(x);\r但是基于范围的for循环可以修改容器的内容，只要指定一个引用参数\rvoid InflateReview(Review \u0026amp;r){r.rating++;}\rfor (auto x : books) InflateReview(x);\r 16.4 泛型编程 面向对象编程关注编程的数据方面，而泛型编程关注的是算法，都是抽象和创建可重用代码。 模板使得算法独立于存储的数据类型，迭代器使算法独立于使用的容器类型。\n16.4.1 迭代器的基本特征  可对迭代器执行解除引用操作，即定义*p； 可将一个迭代器赋给另一个，即定义p=q； 可比较迭代器，即定义p==q，p!=q； 可通过迭代器遍历容器中的所有元素，即定义++p和p++。  5种迭代器： 输入迭代器：读取，单向，可以递增，但不能倒退，每次迭代的顺序不一定相同 输出迭代器：只写，单向 正向迭代器：读写，总是按相同的顺序遍历一系列值，使用++运算符 双向迭代器：具有正向迭代器的所有特性，还可\u0026ndash; 随机访问迭代器：具有双向迭代器的所有特性，还可使用a[10]\ntypedef double * iterator;\riterator find_ar(iterator begin, iterator end, const double \u0026amp; val)\r{\riterator ar;\rfor (ar = begin; ar != end; ar++)\rif (*ar == val)\rreturn ar;\rreturn end;\r}\r 容器有一些基本的特征和要求。 下面就是一些容器类型和用法。\n vector，强调快速访问 deque，双端队列 list，强调快速插入和删除，它表示双向链表 list工具箱 forward_list queue，适配器类 priority_queue，适配器类，与queue的区别在于，它将最大的元素移到队首 stack，适配器类 array，不是STL容器，因为它的长度是固定的  关联容器：基于树结构\n set，可翻转，经过排序 multiset， map multimap，与set类似，但键和值的类型不同，且同一个键可能与多个值相关联 #include \u0026lt;map\u0026gt;\r#include \u0026lt;algorithm\u0026gt;\rtypedef int KeyType;\rtypedef std::pair\u0026lt;const KeyType, std::string\u0026gt; Pair;\rtypedef std::multimap\u0026lt;KeyType, std::string\u0026gt; MapCode;\rint main()\r{\rusing namespace std;\rMapCode codes;\rcodes.insert(Pair(415, \u0026quot;Beijing\u0026quot;));\rcodes.insert(Pair(110, \u0026quot;Nanjing\u0026quot;));\r// Number of cities with area code 415\rcodes.count(415)\rMapCode::iterator it;\rfor (it = codes.begin(); it != codes.end(); ++it)\rcout \u0026lt;\u0026lt; \u0026quot; \u0026quot; \u0026lt;\u0026lt; (*it).first \u0026lt;\u0026lt; \u0026quot; \u0026quot;\r\u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl;\rpair\u0026lt;MapCode::iterator, MapCode::iterator\u0026gt; range\r= codes.equal_range(110);\rfor (it = range.first; it != range.second; ++it)\rcout \u0026lt;\u0026lt; (*it).second \u0026lt;\u0026lt; endl;\rreturn 0;\r}\r   无序关联容器：基于哈希表\n16.5 函数对象 函数对象，也叫函数符（functor），包括函数名、指向函数的指针和重载了()运算符的类对象，它们都可以以函数方式与()结合使用。 STL通过模板解决for_each处理容器中不同类型数据的问题。\ntemplate\u0026lt;class InputIterator, class Function\u0026gt; // 这就是为什么for_each无法修改\rFunction for_each(InputIterator first, InputIterator last, Function f);\r 头文件functional定义了多个模板类函数对象 自适应函数符和函数适配器 自适应生成器、自适应一元函数、自适应二元函数、自适应谓词、自适应二元谓词\n假设有一个自适应二元函数对象f2()，则可以创建一个binder1st对象，使之与第一个参数相关联\nbinder1st(f2, val) f1;\r这样，使用f1(x)时等价于f2(val, x)\r简化版：不需要f2为自适应函数\rbind1st(multiplies\u0026lt;double\u0026gt;(), 2.5)\r 16.6 算法 16.6.1 算法组 STL将算法库分成4组： 头文件algorithm\n 非修改式序列操作； 修改式序列操作； 排序和相关操作；  头文件numeric\n 通用数字运算。  就地算法（in-place algorithm）：sort() 复制算法（copying algorithm）：copy() transform()可以以这两种方式完成工作。\n16.7 其他库 vector, valarray, array initializer_list\nvector是一个容器类和算法系统的一部分，valarray更适合于数组计算，array为替代内置数组而设计，提供更好、更安全的接口，让数组更紧凑、效率更高。\n","id":8,"section":"posts","summary":"第16章 String类和标准模板库 标准C++ string类 模板auto_prt, unique_ptr, shared_ptr\u0026ndash;智能指针 标准模板库（ST","tags":null,"title":"cpp--chapter16--String类和标准模板库","uri":"https://hanin97.cn/2020/12/cpp-chapter16-string%E7%B1%BB%E5%92%8C%E6%A0%87%E5%87%86%E6%A8%A1%E6%9D%BF%E5%BA%93/","year":"2020"},{"content":"第17章 输入、输出和文件 17.4 文件输入和输出 ofstream fout;\rfout.open(\u0026quot;jar.txt\u0026quot;);\r// 默认模式打开文件进行输出，如果没有这样的文件，将创建一个新文件，\r// 如果有这样的文件，则打开文件将清空文件\r// 可以通过ios_base::xx设置模式\r// ofstream fout(\u0026quot;jar.txt\u0026quot;);\rfout \u0026lt;\u0026lt; \u0026quot;Dull Data\u0026quot;;\rifstream fin;\rfin.open(\u0026quot;jar.txt\u0026quot;);\r// ifstream fin(\u0026quot;jar.txt\u0026quot;)\r// 检测文件是否打开成功\rif (fin.fail()) {...}\rif (!fin.good()) {...}\rif (!fin) {...}\rif (fin.is_open()) {...} // best\r ","id":9,"section":"posts","summary":"第17章 输入、输出和文件 17.4 文件输入和输出 ofstream fout; fout.open(\u0026quot;jar.txt\u0026quot;); // 默认模式打开文件进行输出，如果没有这样的文件，将创建一个新文件， // 如果有这样的文件，则打开文","tags":null,"title":"cpp--chapter17--输入、输出和文件","uri":"https://hanin97.cn/2020/12/cpp-chapter17-%E8%BE%93%E5%85%A5%E8%BE%93%E5%87%BA%E5%92%8C%E6%96%87%E4%BB%B6/","year":"2020"},{"content":"第15章 友元、异常和其他  友元类 友元类方法 嵌套类 //上述都是在其他类中声明的类 引发异常、try块和catch块 异常类 运行阶段类型识别（RTTI） dynamic_cast和typeid static_cast、const_cast和reiterpret_cast  15.1 友元类 友元类适用于两个类既不是继承关系，又不是包含关系，但两个类又有关系的情况，如遥控器和电视机。\n// tv.h\r#ifndef TV_H_\r#define TV_H_\rclass Tv\r{\rpublic:\rfriend class Remote; // Remote可以使用Tv的私有成员\renum {Off, On};\renum {MinVal, MaxVal = 20};\renum {Antenna, Cable};\renum {TV, DVD};\rTv(int s = Off, int mc = 125) : state(s), volume(5),\rmaxchannel(mc), channel(2), mode(Cable), input(TC) {}\rvoid onoff() {state = (state == On) ? Off : On;}\r// void onoff() {state ^= 1;}\rbool ison() const {return state == On;}\rbool volup();\rbool voldown();\rvoid chanup();\rvoid chandown();\rvoid set_mode() {mode = (mode == Antenna) ? Cable : Antenna;}\rvoid set_input() {input = (input == TV) ? DVD : TV;}\rvoid setting() const;\rprivate:\rint state;\rint volume;\rint maxchannel;\rint channel;\rint mode;\rint input;\r};\rclass Remote\r{\r...\r};\r...\r 友元成员函数： 仅让特定的类成员成为另一个类的友元。\n// 前向声明，因为Remote的方法提到了Tv对象，且Tv对象中也有Remote方法的声明\r// 在Tv类的声明中看到Remote的一个方法被声明为Tv类的友元之前，应该先看到Remote类\r// 的声明和set_chan()方法的声明；同理，Remote类声明中不要有内联代码，将方法的\r// 定义放在Tv类声明之后，并使用关键字inline使其成为内联方法\rclass Tv;\rclass Remote {...};\rclass Tv\r{\rfriend void Remote::set_chan(Tv \u0026amp; t, int c);\r// 这样Remote类的set_chan成员就可以访问Tv类的私有成员\r};\r 其他友元关系： 两个类互为友元 对于使用Remote对象的Tv方法，其原型可在Remote类声明之前声明，但必须在Remote类声明之后定义。\nclass Tv\r{\rfriend class Remote;\rpublic:\rvoid buzz(Remote \u0026amp; r);\r...\r};\rclass Remote\r{\rfriend class Tv;\rpublic:\rvoid Bool volup(Tv \u0026amp; t) {t.volup();}\r...\r};\rinline void Tv::buzz(Remote \u0026amp; r)\r{\r...\r}\r 共同的友元：\n// 前向声明\rclass Analyzer;\rclass Probe\r{\rfriend void sync(Analyzer \u0026amp; a, const Probe \u0026amp; p);\rfriend void sync(Probe \u0026amp; p, const Analyzer \u0026amp; a);\r...\r}\rclass Analyzer\r{\rfriend void sync(Analyzer \u0026amp; a, const Probe \u0026amp; p);\rfriend void sync(Probe \u0026amp; p, const Analyzer \u0026amp; a);\r...\r};\rinline void sync(Analyzer \u0026amp; a, const Probe \u0026amp; p)\r{\r...\r}\rinline void sync(Probe \u0026amp; p, const Analyzer \u0026amp; a)\r{\r...\r}\r 15.2 嵌套类 在另一个类中声明的类被称为嵌套类（nested class）。包含类的成员函数可以创建和使用被嵌套类的对象，而仅当声明位于共有部分，才能在包含类的外面使用嵌套类，而且必须使用作用域解析运算符。 什么时候需要使用嵌套类：通常是为了帮助实现另一个类，并避免名称冲突，使用类来存放变量可以利用类构造函数方便地赋值。\n15.3 异常  throw语句将控制权向上返回到第一个这样的函数：包含能够捕获相应异常的try-catch组合。 引发异常时编译器总是创建一个临时拷贝。 catch块的排序顺序应该与异常类派生顺序相反，因为引发的异常对象将被第一个与之匹配的catch块捕获。  可以使用省略号来表示异常类型，从而捕获任何异常。  #include \u0026lt;cstdlib\u0026gt;\rstd::abort(); // 发送消息：abnormal program termination，终止程序\rstd::exit(); // 不发送消息，终止程序\r// 更希望遇到异常时进行一些处理，而不是直接终止程序，这时候可以返回错误码或者\r// throw引发异常并用catch捕获异常，try后面可以跟好几个catch与对应异常类型匹配\r// 如果没找到对应的catch，默认异常终止\r// 程序进行栈解退以回到能够捕获异常的地方时，将释放栈中动存储型变量。\r// 如果变量是类对象，将为该对象调用析构函数。\r#include \u0026lt;iostream\u0026gt;\rdouble hmean(double a, double b);\rint main()\r{\rdouble x, y, z;\rstd::cout \u0026lt;\u0026lt; \u0026quot;Enter two numbers: \u0026quot;;\rwhile (std::cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y)\r{\rtry {\rz = heamn(x, y);\r}\rcatch (const char * s) // 与字符串异常匹配\r{\rstd::cout \u0026lt;\u0026lt; s \u0026lt;\u0026lt; std::endl;\rstd::cout \u0026lt;\u0026lt; \u0026quot;Enter a new pair of numbers: \u0026quot;;\rcontinue;\r}\rstd::cout \u0026lt;\u0026lt; \u0026quot;Harmonic mean of \u0026quot; \u0026lt;\u0026lt; x \u0026lt;\u0026lt; \u0026quot; and \u0026quot; \u0026lt;\u0026lt; y\r\u0026lt;\u0026lt; \u0026quot; is \u0026quot; \u0026lt;\u0026lt; z \u0026lt;\u0026lt; std::endl;\rstd::cout \u0026lt;\u0026lt; \u0026quot;Enter next set of numbers. \u0026lt;q to quit\u0026gt;: \u0026quot;;\r}\rstd::cout \u0026lt;\u0026lt; \u0026quot;Bye!\\n\u0026quot;;\rreturn 0;\r}\rdouble hmean(double a, double b)\r{\rif (a == -b)\rthrow \u0026quot;some description\u0026quot;;\rreturn 2.0 * a * b / (a + b);\r}\r exception类 可以将exception类用作异常的基类，里面有个名为what()的虚拟成员函数，它返回一个字符串。 一些基于exception的异常类型。\n stdexcept异常类 这些类中都有一个可以为what()提供返回字符串的构造函数。 两个派生类系列的基类： a. logic_error系列：可通过编程修复  domain_error：定义域 invalid_argument：有效参数 length_error：空间 out_of_bounds：索引错误 b. runtime_error系列：存在无法避免的问题 range_error： overflow_error：上溢 underflow_error：下溢   bad_alloc异常和new 当使用new出现内存分配问题时，以前是返回一个空指针，现在是让new引发bad_alloc异常。 空指针和new 为了兼容以前的返回空指针的new  int * pi = new (std::nothrow) int;\r 异常的意外情况： 意外异常：不与规范列表中的某种异常匹配，先调用unexpected()函数，这个函数将调用terminate()函数，可修改，set_unexpected(func_name) 未捕获异常：不会导致程序立刻终止，而是先调用函数terminate()，默认情况下，terminate()调用abort()函数，可修改，set_terminate(func_name)\n可以设计一个替代函数，将意外异常转换为bad_exception异常\n#include \u0026lt;exception\u0026gt;\rusing namespace std;\rvoid myUnexpected()\r{\rthrow std::bad_exception();\r// 仅使用throw，而不指定异常将导致重新引发原来的异常\r}\r 15.4 RTTI(Runtime Type Identification) 为什么会出现RTTI？想知道类型，那为什么要知道类型呢？1. 派生对象可能包含不是继承而来的方法，只有某些类型的对象可以使用该方法；2. 想跟踪生成的对象的类型。 注意：只能将RTTI用于包含虚函数的类层次结构，因为只有对于这种类层次结构，才应该将派生对象的地址赋给基类指针。\n如何支持RTTI？\n 如果可能的话，dynamic_cast运算符，使用一个指向基类的指针来生成一个指向派生类的指针，否则，该运算符返回0\u0026ndash;空指针； // 指针pg的类型是否可以被安全地转换为Superb *？\r// 可以的话，就返回对象的地址\r// 不可以的话，返回空指针\rSuperb * pm = dynamic_cast\u0026lt;Superb *\u0026gt;(pg);\r  typeid返回一个指出对象的类型的值； // 头文件typeinfo\r// typeid运算符使得能够确定两个对象是否为同种类型\r// 接受两种参数：类名；结果为对象的表达式\r// 返回一个对type_info对象的引用，包含一个name()成员\rtypeid(Magnificent) == typeid(*pg)\r// 如果pg是一个空指针，程序将引发bad_typeid异常\r  type_info结构存储了有关特定类型的信息  15.5 类型转换运算符 🐸：给爷看笑了。 出现的原因：C语言中的类型转换运算符太过松散。 4个类型转换运算符：dynamic_cast; const_cast; static_cast; reinterpret_cast。\n dynamic_cast // 假设High和Low是两个类，ph和pl的类型分别为High*和Low*\r// 则仅当Low是High的可访问基类时，下面的语句才将一个Low*指针赋给pl\r// 这个指针指向谁？\rpl = dynamic_cast\u0026lt;Low *\u0026gt; ph;\r  const_cast // 用于执行只有一种用途的类型转换，即const或volatile\rconst_cast \u0026lt;type-name\u0026gt; (expression)\r// 除了const或volatile特征可以不同外，type_name和expression的类型必须相同\rHigh bar;\rconst High * pbar = \u0026amp;bar;\rHigh * pb = const_cast\u0026lt;High *\u0026gt; (pbar);\r// 使*pb成为一个可用于修改bar对象值的指针\r// 只有当指向的值不是const时才可行\r  static_cast // 仅当type_name可被隐式转换为expression所属的类型或反过来时，转换才是合法的\rstatic_cast \u0026lt;type_name\u0026gt; (expression)\r  reinterpret_cast // 用于天生危险的类型转换\rstruct dat {short a; short b;};\rlong value = 0xA224B11B;\rdat * pd = reinterpret_cast\u0026lt;dat *\u0026gt; (\u0026amp;value);\rcout \u0026lt;\u0026lt; hex \u0026lt;\u0026lt; pd-\u0026gt;a;\r// 显示value的前2个字节\r   ","id":10,"section":"posts","summary":"第15章 友元、异常和其他 友元类 友元类方法 嵌套类 //上述都是在其他类中声明的类 引发异常、try块和catch块 异常类 运行阶段类型识别（RTTI","tags":null,"title":"cpp--chapter15--友元、异常和其他","uri":"https://hanin97.cn/2020/11/cpp-chapter15-%E5%8F%8B%E5%85%83%E5%BC%82%E5%B8%B8%E5%92%8C%E5%85%B6%E4%BB%96/","year":"2020"},{"content":"Deep High-Resolution Representation Learning for Human Pose Estimation 当前问题 大多数现有分割模型/姿态估计模型都是由低分辨率表达恢复高分辨率表达。\n本文特点 在整个网络中保持了高分辨率表达，同时通过并联低分辨率网络来利用多尺度信息，通过融合同level的低分辨率表达来强化高分辨率表达，而不是像U-Net那样融合低维和高维，这样得到的高分率表达信息更丰富（谁知道呢，有的文章还说融合低维和高维更好）\n网络结构 🐸： 既然可以用分割的网络实现关键点预测，那也可以用来细胞检测啊\n","id":11,"section":"posts","summary":"Deep High-Resolution Representation Learning for Human Pose Estimation 当前问题 大多数现有分割模型/姿态估计模型都是由低分辨率表达恢复高分辨率表达。 本文特点 在整个网络中保持了高分辨率表达，同时通过","tags":["Computer Vision","Classification network"],"title":"Deep High-Resolution Representation Learning for Human Pose Estimation","uri":"https://hanin97.cn/2020/11/hrnet/","year":"2020"},{"content":"第14章 C++中的代码重用 🐸小知识： 获得接口是is-a关系的组成部分，不继承接口是has-a关系的组成部分； 当初始化列表包含多个项目时，这些项目被初始化的顺序为它们被声明的顺序，而不是它们在初始化列表中的顺序； 实现has-a关系的途径：包含、私有继承； 通常，使用包含来建立has-a关系，如果需要访问原有类的保护成员，或需重新定义虚函数，则使用私有继承；  14.1 包含对象成员的类 valarray模板类\ndouble gpa[5] = {3.1, 3.5, 3.8, 2.9, 3.3};\rvalarray\u0026lt;double\u0026gt; v1;\rvalarray\u0026lt;int\u0026gt; v2(8);\rvalarray\u0026lt;int\u0026gt; v3(10, 8); // 8个整型元素，每个都为10\rvalarray\u0026lt;double\u0026gt; v4(gpa, 4); // 4个双浮点型，gpa前四个\roperator[]()\rsize()\rsum()\rmax()\rmin()\r 14.2 私有继承 使用私有继承，基类的公有成员和保护成员都将成为派生类的私有成员，派生类不继承基类的接口。 使用强制类型转换来访问基类对象\nclass Student : private std::string, private std::valarray\u0026lt;double\u0026gt;\r{\rpublic:\r...\r};\r 14.2.1 保护继承：保护继承是私有继承的变体 使用保护继承时，基类的公有成员和保护成员都将成为派生类的保护成员，这样就可以在第三代派生类中使用基类的公有方法。 14.2.2 使用using重新定义访问权限 目的：让基类的方法在派生类外面可用\n 定义一个使用该基类方法的派生类方法； double Student::sum() const\r{\rreturn std::valarray\u0026lt;double\u0026gt;::sum();\r}\r  使用一个using声明来指出派生类可以使用特定的基类成员 class Student : private std::string, private std::valarray\u0026lt;double\u0026gt;\r{\rpublic:\rusing std::valarray\u0026lt;double\u0026gt;::min;\rusing std::valarray\u0026lt;double\u0026gt;::max;\r};\r   14.3 多重继承（MI） 需要处理的问题：\n 从两个或更多相关基类那里继承同一个类的多个实例；  SingingWaiter ed;\rWorker * pw = \u0026amp;ed;\r通常，这种赋值将把基类指针设置为派生类对象中的基类对象的地址，但ed中包含两个Worker对象，有两个地址可供选择，所以应使用类型转换来指定对象；（这样将会很复杂）\rWorker * pw1 = (Waiter *) \u0026amp;ed;\rWorker * pw2 = (Singer *) \u0026amp;ed;\r 幸好，C++引入多重继承的同时，引入了一种新技术\u0026ndash;虚基类，它使得从多个类（它们的基类相同）派生出的对象只继承一个基类对象。\nclass Singer : virtual public Worker {...};\rclass Waiter : public virtual Worker {...};\r 这样做会出现一个问题：派生类构造函数在向基类传递参数时，由于有2条不同的途径，会产生冲突，所以C++在基类是虚的时，禁止信息通过中间类自动传递给基类。\nSingingWaiter(const Worker \u0026amp; wk, int p = 0, int v = Singer::other)\r: Waiter(wk, p), Singer(wk, v) {}\r上构造函数将初始化Waiter的成员panache和Singer的成员voice，但wk参数中的信息不会传递给子对象Waiter，这时，编译器将使用Worker的默认构造函数。\rSingingWaiter(const Worker \u0026amp; wk, int p = 0, int v = Singer::other)\r: Worker(wk), Waiter(wk, o), Singer(wk, v)\r 从两个不同的基类继承同名方法 a. 使用作用域解析运算符 SingingWaiter newhire(\u0026quot;jhan\u0026quot;, 2005, 6, soprano);\rnewhire.Singer::Show();\r b. 重新定义\nvoid SingingWaiter::Show()\r{\rSinger::Show();\r}\r   14.4 类模板 生成通用的类声明。模板的具体实现被称为实例化或具体化。 如果在类声明中定义了方法（内联定义），则可以省略模板前缀和类限定符。\n// stacktp.h -- a stack template\r#ifndef STACKTP_H_\r#define STACKTP_H_\rtemplate \u0026lt;class Type\u0026gt;\rclass Stack\r{\rprivate:\renum {MAX = 10};\rType items[MAX];\rint top;\rpublic:\rStack();\rbool isempty();\rbool isfull();\rbool push(const Type \u0026amp; item);\rbool pop(Type \u0026amp; item);\r};\rtemplate \u0026lt;class Type\u0026gt;\rStack\u0026lt;Type\u0026gt;::Stack()\r{\rtop = 0;\r}\rtemplate \u0026lt;class Type\u0026gt;\rbool Stack\u0026lt;Type\u0026gt;::isempty()\r{\rreturn top == 0;\r}\rtemplate \u0026lt;class Type\u0026gt;\rbool Stack\u0026lt;Type\u0026gt;::isfull()\r{\rreturn top == MAX;\r}\rtemplate \u0026lt;class Type\u0026gt;\rbool Stack\u0026lt;Type\u0026gt;::push(const Type \u0026amp; item)\r{\rif (top \u0026lt; MAX)\r{\ritems[top++] = item;\rreturn true;\r}\relse\rreturn false;\r}\rtemplate \u0026lt;class Type\u0026gt;\rbool Stack\u0026lt;Type\u0026gt;::pop(Type \u0026amp; item)\r{\rif (top \u0026gt; 0)\r{\ritem = items[--top];\rreturn true;\r}\relse\rreturn false;\r}\r// stackem.cpp -- testing the template stack class\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;string\u0026gt;\r#include \u0026lt;cctype\u0026gt;\r#include \u0026quot;stacktp.h\u0026quot;\rusing std::cin;\rusing std::cout;\rint main()\r{\rStack\u0026lt;std::string\u0026gt; st;\rchar ch;\rstd::string po;\r...\r}\r 其他类型的模板头：\n1. template \u0026lt;class Type, int n\u0026gt;\r第二个参数称为非类型或表达式参数，表达式参数可以使整型、枚举、引用或指针。\r缺点：每种数组大小都生成自己的模板，即不同的n将生成不同的独立的类声明。\r2. template \u0026lt;class T1, class T2\u0026gt;\r3. template \u0026lt;class T1, class T2 = int\u0026gt;\rclass Topo\r{\r...\r};\r 模板的具体化\n 隐式实例化 ArrayTP\u0026lt;int, 100\u0026gt; stuff; 显式实例化 template class ArrayTP\u0026lt;string, 100\u0026gt;; 显式具体化 用于为特殊类型实例化时，对模板进行修改，使其行为不同。 template \u0026lt;\u0026gt; class Classname\u0026lt;specialized-type-name\u0026gt; { ... };  成员模板\n// tempmemb.cpp -- template members\r#include \u0026lt;iostream\u0026gt;\rusing std::cout;\rusing std::endl;\rtemplate \u0026lt;typename T\u0026gt;\rclass beta\r{\rprivate:\rtemplate \u0026lt;typename V\u0026gt;\rclass hold\r{\rprivate:\rV val;\rpublic:\rhold(V v = 0) : val(v) {}\rvoid show() const {cout \u0026lt;\u0026lt; val \u0026lt;\u0026lt; endl;}\rV Value() const {return val;}\r};\rhold\u0026lt;T\u0026gt; q;\rhold\u0026lt;int\u0026gt; n;\rpublic:\rbeta(T t, int i) : q(t), n(i) {}\r// 模板函数\rtemplate\u0026lt;typename U\u0026gt;\rU blab(U u, T t) {return (n.Value() + q.Value()) * u / t;}\rvoid Show() const {q.show(); n.show();}\r};\rq成员是基于T类型的hold对象，blab()方法的U类型由该方法被调用时的参数值显示确定，T类型是由对象的实例化类型确定。\r 模板用作参数\ntemplate \u0026lt;template \u0026lt;typename T\u0026gt; class Thing\u0026gt;\rclass Crab\r{\rprivate:\rThing\u0026lt;int\u0026gt; s1;\rThing\u0026lt;double\u0026gt; s2;\rpublic:\rCrab() {};\rbool push(int a, double x) {return s1.push(a) \u0026amp;\u0026amp; s2.push(x);}\rbool pop(int \u0026amp; a, double \u0026amp; x) {return s1.pop(a) \u0026amp;\u0026amp; s2.pop(x);}\r};\rCrab\u0026lt;Stack\u0026gt; nebula;\r// Thing\u0026lt;int\u0026gt;将被实例化为Stack\u0026lt;int\u0026gt;\r 头疼，模板类和友元，每种都适合于什么样的场景呢？ 非模板友元函数、约束模板友元函数、非约束模板友元函数\n","id":12,"section":"posts","summary":"第14章 C++中的代码重用 🐸小知识： 获得接口是is-a关系的组成部分，不继承接口是has-a关系的组成部分； 当初始化列表包含多个项目时，这些","tags":null,"title":"cpp--chapter14--C++中的代码重用","uri":"https://hanin97.cn/2020/11/cpp-chapter14-c-%E4%B8%AD%E7%9A%84%E4%BB%A3%E7%A0%81%E9%87%8D%E7%94%A8/","year":"2020"},{"content":"Contrastive Adaptation Network for Unsupervised Domain Adaptation 预备知识 在域级别衡量域不一致性。\n Maximum Mean Discrepancy （MMD） Joint MMD  目标 使用有标记的源域数据预测无标记的目标域数据。\n已有方法的缺点 之前的方法通过最小化域间不一致性来实现域适应，忽略了类信息，会导致不匹配和差的泛化性。举个例子，在域适应之前两个域的决策边界都好优化出来，域适应过后，虽然能让两个域的特征空间类似，但是不同类别的特征信息可能会接近，导致最后的分类效果不好，究其原因，域适应时没有考虑类信息，导致结果的不确定性。\n本文方法 Contrastive Domain Discrepancy (CDD) $$ \\hat{D}^{cdd} = \\frac{1}{M}\\sum\\limits_{c=1}^{M}{\\hat{D}^{cc}(\\hat{y}_{1:n_t}^t, \\phi)} - \\frac{1}{M(M-1)}\\sum\\limits_{c=1}^{M}\\sum\\limits_{c'=1, c'\\neq c}^{M}{\\hat{D}^{cc'}(\\hat{y}_{1:n_t}^t, \\phi)} $$\n在全连接层最小化CDD，即$\\hat{D}L^{cdd}=\\sum\\limits{l=1}^L{\\hat{D}l^{cdd}}$ 同时最小化交叉熵损失，即$l^{ce}=\\frac{1}{n's}\\sum\\limits{i'=1}^{n's}logP\\theta(y{i'}^s|x_{i'}^s)$ 最终的目标函数：两者之和（$\\hat{D}^{cdd}$加权重）\n更新策略 在每个loop中，先验证是否满足终止训练条件，若不满足，则再使用源域样本训练，计算交叉熵损失并回传，然后按类别取样并计算CDD损失回传，最后更新权重。\n源域和目标域的BatchNormlize是分开的， 在前向传播时，分别设置使用的BN。\n🌈小问题：  说是无监督的域适应，但是在dataloader取样的时候，为了能在每个batch都能计算类内距离，还是考虑了目标域的标签，至于这个标签是真实的标签还是聚类得到的标签有待查证; \u0026ndash;在‘/media/jhan/Jineng-4T/jhan/Office-31/CAN/data/categorical_dataset.py’中的参数target_paths没有明确，倒要看看是什么妖魔鬼怪：是根据聚类的结果给的标签 聚类筛选样本需要设置的参数有两个，一个是聚类簇中心的距离，一个是每个类最少的样本数，可能影响最终结果；  ","id":13,"section":"posts","summary":"Contrastive Adaptation Network for Unsupervised Domain Adaptation 预备知识 在域级别衡量域不一致性。 Maximum Mean Discrepancy （MMD） Joint MMD 目标 使用有标记的源域数据预测无标记的目标域数据。 已有方法的缺点 之前的方法通","tags":["domain adaptation"],"title":"Contrastive Adaptation Network for Unsupervised Domain Adaptation","uri":"https://hanin97.cn/2020/11/can-uda/","year":"2020"},{"content":"第13章 类继承 🐸小知识： 以前一直以为继承跟直接复制再添加没啥区别，而且就算使用继承，也得先了解基类的特性，熟悉基类，现在有一点让我对继承有了新的看法：它甚至不需要访问源代码就可以派生出类，可以在不公开实现的情况下将自己的类分发给其他人，不过对个人来讲，这没啥用； 派生类需要自己的构造函数； 基类指针可以在不进行显式类型转换的情况下指向派生类对象，基类引用可以在不进行显式类型转换的情况下引用派生类对象，但是只能调用基类方法； C++继承的3种方式：公有继承、保护继承、私有继承； 方法在基类中被声明为虚的后，它在派生类中将自动成为虚方法，在派生类声明中使用关键字virtual来指出哪些函数是虚函数也不失为一个好办法； 通常为基类声明一个虚析构函数，这样做是为了确保释放派生对象时，按正确的顺序调用析构函数（怎么确保呢？）； 关键字virtual只用于类声明的方法原型中，而不用在定义中；  13.1 简单基类 // tabtenn0.h\r#ifndef TABTENN0_H_\r#define TABTENN0_H_\r#include \u0026lt;string\u0026gt;\rusing std::string;\rclass TableTennisPlayer\r{\rprivate:\rstring firstname;\rstring lastname;\rbool hasTable;\rpublic:\rTableTennisPlayer (const string \u0026amp; fn = \u0026quot;none\u0026quot;,\rconst string \u0026amp; ln = \u0026quot;none\u0026quot;, bool ht = false);\rvoid Name() const;\rbool HasTable() const {return hasTable;};\rvoid ResetTable(bool v) {hasTable = v;};\r};\r// tabtenn0.cpp\r#include \u0026quot;tabtenn0.h\u0026quot;\r#include \u0026lt;iostream\u0026gt;\rTableTennisPlayer::TableTennisPlayer (const string \u0026amp; fn,\rconst string \u0026amp; ln, bool ht) : firstname(fn),\rlastname(ln), hasTable(ht) {}\rvoid TableTennisPlayer::Name() const\r{\rstd::cout \u0026lt;\u0026lt; lastname \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; firstname;\r}\r 派生一个类\n// 公有派生：基类的公有成员将成为派生类的公有成员，\r// 基类的私有部分也将成为派生类的一部分，但只能通过基类的公有和保护方法访问\rclass RatedPlayer : public TableTennisPlayer\r{\rprivate:\runsigned int rating;\rpublic:\rRatedPlayer (unsigned int r = 0, const string \u0026amp; fn = \u0026quot;none\u0026quot;,\rconst string \u0026amp; ln = \u0026quot;none\u0026quot;, bool ht = false);\rRatedPlayer (unsigned int r, const TableTennisPlayer \u0026amp; tp);\runsigned int Rating() const {return rating;}\rvoid ResetRating (unsigned int r) {rating = r;}\r};\r// 创建派生类对象时，程序首先创建基类对象，\r// 这意味着基类对象应当在程序进入派生类构造函数之前被创建\rRatedPlayer::RatedPlayer(unsigned int r, const string \u0026amp; fn,\rconst string \u0026amp; ln, bool ht) : TableTennisPlayer(fn, ln, ht)\r{\rrating = r;\r}\rRatedPlayer::RatedPlayer(unsigned int r, const TableTennisPlayer \u0026amp; tp)\r: TableTennisPlayer(tp)\r{\rrating = r;\r}\r// 如果不调用基类构造函数，程序将使用默认的基类构造函数\rRatedPlayer::RatedPlayer(unsigned int r, const string \u0026amp; fn,\rconst string \u0026amp; ln, bool ht)\r{\rrating = r;\r}\r等价于\rRatedPlayer::RatedPlayer(unsigned int r, const string \u0026amp; fn,\rconst string \u0026amp; ln, bool ht) : TableTennisPlayer()\r{\rrating = r;\r}\r 基类指针与引用\nRatedPlayer rplayer(1140, \u0026quot;Jineng\u0026quot;, \u0026quot;Han\u0026quot;, true);\rTableTennisPlayer \u0026amp; rt = rplayer;\rTableTennisPlayer * pt = \u0026amp;rplayer;\rrt.Name();\rpt-\u0026gt;Name();\rrt.Rating(); // invalid\r 13.2 继承：Is-a关系 C++继承的3种方式：公有继承、保护继承、私有继承。\n公有继承建立一种is-a-kind-of关系（is-a，香蕉是一种水果），不建立has-a关系（午餐有水果），不能建立is-like-a关系（我像小太阳），不建立is-implemented-as-a关系（用数组实现栈），不建立uses-a关系（计算机使用打印机）。\n13.3 多态公有继承 它是为了处理这样的情况的：希望同一个方法在派生类和基类中的行为不同。 可以使用两种机制实现多态公有继承：\n 在派生类中重新定义基类的方法； 使用虚方法（经常在基类中将派生类会重新定义的方法声明为虚方法）；  // brass.h\r#ifndef BRASS_H_\r#define BRASS_H_\r#include \u0026lt;string\u0026gt;\r// 基类中也要加关键字virtual？修改不方便啊，谁知道写基类的时候哪个方法要被重用呢\rclass Brass\r{\rprivate:\rstd::string fullName;\rlong accNum;\rdouble balance;\rpublic:\rBrass(const std::string \u0026amp; s = \u0026quot;Nullbody\u0026quot;,\rlong an = -1, double bal = 0.0);\rvoid Deposit(double amt);\rvirtual void Withgraw(double amt);\rdouble Balance() const;\rvirtual void ViewAcct() const;\rvirtual ~Brass() {}\r};\rclass BrassPlus : public Brass\r{\rprivate:\rdouble maxLoan;\rdouble rate;\rdouble owesBank;\rpublic:\rBrassPlus(const std::string \u0026amp; s = \u0026quot;Nullbody\u0026quot;, long an = -1,\rdouble bal = 0.0, double ml = 500, double r = 0.11125);\rBrassPlus(const Brass \u0026amp; ba, double ml = 500, double r = 0.11125);\rvirtual void ViewAcct() const;\rvirtual void Withgraw(double amt);\rvoid ResetMax(double m) {maxLoan = m;}\rvoid ResetRate(double r) {rate = r;}\rvoid ResetOwes() {owesBank = 0;}\r};\r#endif\r 如果没有使用关键字virtual，程序将根据引用类型或指针类型选择方法；如果使用了virtual，程序将根据引用或指针指向的对象的类型来选择方法，例如：\n如果ViewAcct()不是虚的：\rBrass dom(\u0026quot;jhan\u0026quot;, 123421, 12435.65);\rBrassPlus dot(\u0026quot;han\u0026quot;m 12434, 1243.54);\rBrass \u0026amp; b1_ref = dom;\rBrass \u0026amp; b2_ref = dot;\rb1_ref.ViewAcct(); // use Brass::ViewAcct()\rb2_ref.ViewAcct(); // use Brass::ViewAcct()\r如果ViewAcct()是虚的：\rb1_ref.ViewAcct(); // use Brass::ViewAcct()\rb2_ref.ViewAcct(); // use BrassPlus::ViewAcct()\r 13.4 静态联编和动态联编 隐式向上强制转换使基类指针或引用可以指向基类对象或派生类对象。\n虚函数的工作原理： 实现虚函数功能的是一个保存了指向函数地址数组的指针的隐藏成员（虚函数表），若派生类重新定义了基类的虚函数，则派生类的虚函数表存储的地址替换为新的虚函数地址，否则地址仍为基类虚函数的地址，调用函数时，到对应的虚函数表中查找地址。\n注意点：\n 构造函数不能是虚函数； 析构函数应当是虚函数，除非类不用做基类，要不然指向基类的指针就不能调用派生类的析构函数来释放内存了； 友元不能是虚函数，因为友元不是类成员； 如果派生类没有重新定义函数，将使用该函数的基类版本，如果派生类位于派生链中，则将使用最新的虚函数版本（递进原则）； 派生类的虚函数将隐藏基类的；  13.5 访问控制：protected protected与private的共同点：在类外只能用公有类成员来访问protected部分中的类成员； protected与private的区别：派生类的成员可以直接访问基类的保护成员，但不能访问基类的私有成员。 小提示： 尽量对类数据成员采用私有访问控制。\n13.6 抽象基类 用来处理两个类有很多共同点，但实际继承时又有许多麻烦的情况，这时，可以从这两个类中抽象出来它们的共性，将这些特性放到一个ABC中。通过纯虚函数来实现ABC。 🐸小知识： 当类声明中包含纯虚函数时，不能创建该类的对象，包含纯虚函数的类只用作基类； 纯虚函数的结尾处为=0，virtual double Area() const = 0;； 如果所有共性的基类方法都一样，可以通过将原型声明为虚的来使基类成为抽象的void Move(int nx, ny) = 0;；  13.7 继承和动态内存分配 如果基类使用动态内存分配，并重新定义赋值和复制构造函数，派生类的实现会受到怎样的影响？\n 派生类不使用new 不需要为派生类定义显式析构函数、复制构造函数和赋值运算符，默认的就能满足了； 派生类使用new 必须为派生类定义显式析构函数、复制构造函数和赋值运算符。  析构函数：依赖于基类的析构函数释放基类中的指针数据成员，并释放派生类指针数据成员管理的内存。  baseDMA::~baseDMA()\r{\rdelete [] label;\r}\rhasDMA::~hasDMA()\r{\rdelete [] style;\r}\r 复制构造函数 复制构造函数baseDMA有一个baseDMA引用参数，基类引用可以指向派生类型，因此，baseDMA复制构造函数将使用hasDMA参数的baseDMA部分来构造新对象的baseDMA部分。  hasDMA::hasDMA(const hasDMA \u0026amp; hs) : baseDMA(hs)\r{\rstyle = new char[std::strlen(hs.style) + 1];\rstd::strcpy(style, hs.style);\r}\r 赋值运算符 显式调用基类赋值运算符baseDMA::operator=(hs)。    派生类如何使用基类的友元？ 使用基类的；强制类型转换\n","id":14,"section":"posts","summary":"第13章 类继承 🐸小知识： 以前一直以为继承跟直接复制再添加没啥区别，而且就算使用继承，也得先了解基类的特性，熟悉基类，现在有一点让我对继承有了","tags":null,"title":"cpp--chapter13--类继承","uri":"https://hanin97.cn/2020/11/cpp-chapter13-%E7%B1%BB%E7%BB%A7%E6%89%BF/","year":"2020"},{"content":"第12章 类和动态内存分配 12.1 动态内存和类 想在类中使用new和delete运算符，将会比平时多出许多问题，在这种情况下，析构函数必不可少。\n🐸小知识： 静态类成员特点：无论创建了多少对象，程序都只创建一个静态类变量副本； 可以在类声明之外使用单独的语句初始化静态类成员；  // stringbad.h\r#include \u0026lt;iostream\u0026gt;\r#ifndef STRINGBAD_H_\r#define STRINGBAD_H_\rclass StringBad\r{\rprivate:\rchar * str;\rint len;\rstatic int num_strings;\rpublic:\rStringBad(const char * s);\rStringBad();\r~StringBad();\rfriend std::ostream \u0026amp; operator\u0026lt;\u0026lt;(std::ostream \u0026amp; os, const StringBad \u0026amp; st);\r};\r#endif\r// stringbad.cpp\r#include \u0026lt;cstring\u0026gt;\r#include \u0026quot;stringbad.h\u0026quot;\rusing std::cout;\rint StringBad::num_strings = 0;\rStringBad::StringBad(const char * s)\r{\rlen = std::strlen(s);\rstr = new char[len + 1];\rstd::strcpy(str, s);\rnum_strings++;\rcout \u0026lt;\u0026lt; num_strings \u0026lt;\u0026lt; \u0026quot;: \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str\r\u0026lt;\u0026lt; \u0026quot;\\\u0026quot; object created\\n\u0026quot;;\r}\rStringBad::StringBad()\r{\rlen = 4;\rstr = new char[4];\rstd::strcpy(str, \u0026quot;C++\u0026quot;);\rnum_strings++;\rcout \u0026lt;\u0026lt; num_strings \u0026lt;\u0026lt; \u0026quot;: \\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str\r\u0026lt;\u0026lt; \u0026quot;\\\u0026quot; default object created\\n\u0026quot;;\r}\rStringBad::~StringBad()\r{\rcout \u0026lt;\u0026lt; \u0026quot;\\\u0026quot;\u0026quot; \u0026lt;\u0026lt; str \u0026quot;\\\u0026quot; object deleted, \u0026quot;;\r--num_strings;\rcout \u0026lt;\u0026lt; num_strings \u0026lt;\u0026lt; \u0026quot; left\\n\u0026quot;;\rdelete [] str;\r}\rstd::ostream \u0026amp; operator\u0026lt;\u0026lt;(std::ostream \u0026amp; os, const StringBad \u0026amp; st)\r{\ros \u0026lt;\u0026lt; st.str;\rreturn os;\r}\r 12.2 构造函数中使用new的注意事项  如果在构造函数中使用new来初始化指针成员，则应在析构函数中使用delete； new和delete必须相互兼容，new对应于delete，new[]对应于delete[]； 如果有多个构造函数，则必须以相同的方式使用new，因为析构函数只有一个； 应定义一个复制构造函数，通过深度复制将一个对象初始化为另一个对象； String::String(const String \u0026amp; st)\r{\rnum_strings++;\rlen = st.len;\rstr = new char [len + 1];\rstd::strcpy(str, st.str);\r}\r  应定义一个赋值运算符，通过深度复制将一个对象复制给另一个对象； String \u0026amp; String::operator=(const String \u0026amp; st)\r{\rif (this == \u0026amp;st)\rreturn *this;\rdelete [] str;\rlen = st.len;\rstd::strcpy(str, st.str);\rreturn *this;\r}\r   🌈小提示：到目前为止，涉及的都是在一个类内，那如果一个类包含其他类呢？这些函数要怎么变？ 第一种情况，类中没有其他需要复制构造函数和赋值运算符的成员：\n// String and string\rclass Magazine\r{\rprivate:\rString title;\rstring publisher;\r}\r 这个例子中，不需要为Magazine类编写复制构造函数和赋值运算符，因为逐成员复制将使用成员类型定义的复制构造函数和赋值运算符。 第二种情况，类中有其他需要复制构造函数和赋值运算符的成员： 这些函数必须显式地调用String和string的复制构造函数和赋值运算符。\n12.3 有关返回对象的说明  返回对象将调用复制构造函数，而返回引用不会； 如果被返回的对象是被调用函数中的局部变量，则应返回对象； 返回const对象有助于防止将其作为左值； 如果方法或函数要返回一个没有公有复制构造函数的类的对象，它必须返回一个纸箱这种对象的引用；  12.4 指针和对象  使用常规表示法来声明指向对象的指针； 可以将指针初始化为指向已有对象； 可以使用new来初始化指针，这将创建一个新的对象； 对类使用new将调用相应的类构造函数来初始化新创建的对象； 可以使用-\u0026gt;运算符通过指针访问类方法； 可以对对象指针应用解除引用运算符(*)来获得对象； delete不能与定位new运算符配合使用（挺难的），需要显式地调用析构函数  #include \u0026lt;iostream\u0026gt;\r#include \u0026lt;string\u0026gt;\r#include \u0026lt;new\u0026gt;\rusing namespace std;\rconst int BUF = 512;\rclass JustTesting\r{\rprivate:\rstring words;\rint number;\rpublic:\rJustTesting(const string \u0026amp; s = \u0026quot;Just Testing\u0026quot;, int n = 0)\r{words = s; number = n; cout \u0026lt;\u0026lt; words \u0026lt;\u0026lt; \u0026quot; constructed\\n\u0026quot;;}\r~JustTesting() {cout \u0026lt;\u0026lt; words \u0026lt;\u0026lt; \u0026quot; destroyed\\n\u0026quot;;}\rvoid Show() const {cout \u0026lt;\u0026lt; words \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; number \u0026lt;\u0026lt; endl;}\r};\rint main()\r{\rchar * buffer = new char[BUF];\rJustTesting *pc1, pc2;\rpc1 = new (buffer) JustTrsting;\rpc2 = new JustTesting(\u0026quot;Heap1\u0026quot;, 20);\rcout \u0026lt;\u0026lt; \u0026quot;Memory block addressed:\\n\u0026quot; \u0026lt;\u0026lt; \u0026quot;buffer: \u0026quot;\r\u0026lt;\u0026lt; (void *) buffer \u0026lt;\u0026lt; \u0026quot; heap: \u0026quot; \u0026lt;\u0026lt; pc2 \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;Memory contents:\\n\u0026quot;;\rcout \u0026lt;\u0026lt; pc1 \u0026lt;\u0026lt; \u0026quot;: \u0026quot;;\rpc1-\u0026gt;Show();\rcout \u0026lt;\u0026lt; pc2 \u0026lt;\u0026lt; \u0026quot;: \u0026quot;;\rpc2-\u0026gt;Show();\rJustTesting *pc3, *pc4;\r// 偏移量sizeof(JustTesting)\rpc3 = new (buffer + sizeof(JustTesting)) JustTesting(\u0026quot;Better Idea\u0026quot;, 6);\rpc4 = new JustTesting(\u0026quot;Heap2\u0026quot;, 10);\rcout \u0026lt;\u0026lt; \u0026quot;Memory contents:\\n\u0026quot;;\rcout \u0026lt;\u0026lt; pc3 \u0026lt;\u0026lt; \u0026quot;: \u0026quot;;\rpc1-\u0026gt;Show();\rcout \u0026lt;\u0026lt; pc4 \u0026lt;\u0026lt; \u0026quot;: \u0026quot;;\rpc2-\u0026gt;Show();\rdelete pc2;\rdelete pc4;\rpc3-\u0026gt;~JustTesting();\rpc4-\u0026gt;~JustTesting();\rdelete [] buffer;\rcout \u0026lt;\u0026lt; \u0026quot;Done\\n\u0026quot;;\rreturn 0;\r}\r 12.5 队列 🐸小知识： 可以对常量进行初始化，但不能给它赋值，因此，对于const数据成员，必须在执行到构造函数体之前，即创建对象时进行初始化，C++可以用成员初始化列表完成这项工作，它并不限于初始化常量； 被声明为引用的类成员同上； // 成员初始化列表语法，这种格式只适用于构造函数\rClassy::Classy(int n, int m) : mem1(n), mem2(0), mem3(n*m + 2)\r{\r//...\r}\r// 这个实现方法无法正常运行\rQueue::Queue(int qs)\r{\rfront = rear = NULL;\ritem = 0;\rqsize = qs;\r}\r// 这个可以\rQueue::Queue(int qs) : qsize(qs)\r{\rfront = rear = NULL;\ritem = 0;\r}\r   先进先出（FIFO）\nclass Queue\r{\rprivate:\rstruct Node {Item item; struct Node * next;}\renum {Q_SIZE = 10};\rNode * front;\rNode * rear;\rint items;\rconst int qsize;\rpublic:\rQueue(int qs = Q_SIZE);\r~Queue();\rbool isempty() const;\rbool isfull() const;\rint queuecount() const;\rbool enqueue(const Item \u0026amp;item);\rbool dequeue(Item \u0026amp;item);\r};\r ","id":15,"section":"posts","summary":"第12章 类和动态内存分配 12.1 动态内存和类 想在类中使用new和delete运算符，将会比平时多出许多问题，在这种情况下，析构函数必不可少。 🐸小知","tags":null,"title":"cpp--chapter12--类和动态内存分配","uri":"https://hanin97.cn/2020/11/cpp-chapter12-%E7%B1%BB%E5%92%8C%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/","year":"2020"},{"content":"DROPEDGE: TOWARDS DEEP GRAPH CONVOLUTIONAL NETWORKS ON NODE CLASSIFICATION 1. 背景 过拟合和过度平滑是当前节点分类的两个主要困难。\n2. 解决方法 DropEdge策略： 并不是网络结构的创新，只是在每个epoch后随机丢掉某个数量的边。 处理overfitting： DropEdge像一种数据增强的方法，每次dropedge后相当于得到了原图的变形副本，从邻居信息聚合的角度看，以概率$p$丢弃边后再对边权重归一化，并没有改变邻居聚合的期望，所以这是一种无偏数据增强方法； 处理oversmoothing： DropEdge让节点的连接更稀疏，所以在某种程度上可以避免oversmoothing（过度平滑正是由于网络层数加深，节点汇聚的信息范围越来越大，导致最终各个节点的特征趋于一致）；\n具体方法： 假设$E$是边的总数量，$A$为邻接矩阵，$p$是丢弃率，$E_p$是要丢弃的边的数量，则 $$A_{drop} = A - A'$$ 其中$A'$由最初的边$E$的随机子集$E_p$得到，$A_{drop}$重新归一化后为$\\hat A_{drop}$。 验证和测试的时候不使用DropEdge。\n3. 实验 从实验结果可以看出两点：\n 并不是网络越深效果越好，网络的深度要考虑数据集的大小； 在有的数据集上使用DropEdge策略提升的多，有的却几乎没变化； IncepGCN效果相对于其他的网络性能略胜一筹；  由此引发思考：\n 既然文中说自己的方法能处理过拟合，那就算网络深了，效果最起码不应该变差啊（像ResNet中说的那样），可是这里怎么会越来越差呢？发生了梯度消失？  下面还做了实验来分析DropEdge起到的作用\n","id":16,"section":"posts","summary":"DROPEDGE: TOWARDS DEEP GRAPH CONVOLUTIONAL NETWORKS ON NODE CLASSIFICATION 1. 背景 过拟合和过度平滑是当前节点分类的两个主要困难。 2. 解决方法 DropEdge策略： 并不是网络结构的创新，只是在每个epo","tags":["GNN"],"title":"DROPEDGE: TOWARDS DEEP GRAPH CONVOLUTIONAL NETWORKS ON NODE CLASSIFICATION","uri":"https://hanin97.cn/2020/11/dropedge/","year":"2020"},{"content":"🐸第11章 使用类 11.1 运算符重载 运算符重载是一种形式的C++多态，可使代码看起来更自然，隐藏内部机理，强调实质。\noperatorop(argument-list)\r// 重载+运算符\roperator+()\r 🌈一些限制：\n 重载后的运算符必须至少有一个操作数是用户定义的类型，防止用户为标准类型重载运算符； 使用运算符时不能违反操作符原来的句法规则，包括优先级； 不能创建新运算符； 不能重载下面的运算符：  sizeof . .* :: ?: typeid 强制类型转换运算符const_cast, dynamic_cast, reinterpret_cast, static_cast   下面的运算符只能使用成员函数重载  = () [] -\u0026gt;    11.2 友元 🐸小知识： 友元有三种：友元函数、友元类、友元成员函数。 通过让函数成员友元函数，可以赋予该函数与类的成员函数相同的访问权限。 在为类重载二元运算符时（操作数类型不一样）常常需要友元，以实现交换顺序也能运算，而不是必须左侧操作数为调用对象。 注意友元函数不在类作用域内，因此使用类成员时要加限定。  创建友元函数：把原型放在类声明中，并在前面加上关键字friend，但定义时不需要加friend，也不需要加限定符\nTime operator*(double n) const;\rA = B * 2.75;\r将被转换为下面的成员函数调用\rA = B.operator*(2.75);\r那A = 2.75 * B怎么办呢？这时候友元函数就派上用场了\rfriend Time operator*(double m, const Time \u0026amp; t);\r意味着以下两点：\r1. 它不是成员函数；\r2. 它与成员函数的访问权限相同。\r下面的两个原型将冲突\rTime operator+(const Time \u0026amp; t) const;\rfriend Time operator+(const Time \u0026amp; t1, const Time \u0026amp; t2);\r 运算符\u0026laquo;重载\n1. 第一种\rvoid operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const Time \u0026amp; t)\r{\ros \u0026lt;\u0026lt; t.hours \u0026lt;\u0026lt; \u0026quot; hours, \u0026quot; \u0026lt;\u0026lt; t.minutes \u0026lt;\u0026lt; \u0026quot; minutes\u0026quot;;\r}\r2. 第二种\rostream \u0026amp; operator\u0026lt;\u0026lt;(ostream \u0026amp; os, const Time \u0026amp; t)\r{\ros \u0026lt;\u0026lt; t.hours \u0026lt;\u0026lt; \u0026quot; hours, \u0026quot; \u0026lt;\u0026lt; t.minutes \u0026lt;\u0026lt; \u0026quot; minutes\u0026quot;;\rreturn os;\r}\r第一种重载不可以使用`cout \u0026lt;\u0026lt; \u0026quot;Trip time: \u0026quot; \u0026lt;\u0026lt; trip \u0026lt;\u0026lt; \u0026quot; (Tuesday)\\n\u0026quot;;`\r第二种重载就可以，因为它返回的是ostream对象的引用。\r 11.3 类的自动转换和强制类型转换 🐸小知识： 只有接受一个参数的构造函数才能作为转换函数，如果是多个参数，但第二个以后都提供默认值也可以； 只有接受一个参数的构造函数可以将类型与该参数相同的值转换为类； 构造函数只用于从某种类型到类类型的转换，要进行相反的转换，需要使用转换函数； 默认的复制构造函数和赋值运算符为浅复制，即对成员进行逐个复制，可能导致数据受损； delete[]与使用new[]初始化的指针和空指针str = 0; str = nullptr;兼容  构造函数类型转换\nStonewt(double lbs);\rStonewt myCat;\rmyCat = 19.6; // 如果声明了要显式，则该语句无效\rmycat = Stonewt(19.6);\rmycat = (Stonewt) 19.6;\r程序将使用构造函数Stonewt(double)来创建一个临时的Stonewt对象，并将19.6作为初始化值，随后，采用逐成员赋值方式将该临时对象的内容复制到mtCar中，这一过程叫隐式转换。\r可以使用explicit关闭自动隐式转换。（谨慎地使用隐式转换）\rexplicit Stonewt(double lbs);\r 转换函数类型转换\n声明\roperator typeName() const;\r定义\rclassName::operator typeName() const\r{\rreturn typeName (xxx)\r}\r 复制构造函数、 用于将一个对象复制到新创建的对象中。 每当程序生成了对象副本时，编译器都将使用复制构造函数。\n原型\rClass_name(const Class_name \u0026amp;);\r何时调用？\r新建一个对象并将其初始化为同类现有对象时，复制构造函数将被调用\r假设motto是一个StringBad对象，则下面4种声明都将调用复制构造函数：\rStringBad ditto(motto);\rStringBad metto = motto;\rStringBad also = StringBad(motto);\rStringBad * pStringBad = new StringBad(motto);\r 赋值运算符 将已有的对象赋给另一个对象时，将使用重载的赋值运算符。\nStringBad headline1(\u0026quot;Jineng Han\u0026quot;);\rStringBad knot;\rknot = headline1;\r ","id":17,"section":"posts","summary":"🐸第11章 使用类 11.1 运算符重载 运算符重载是一种形式的C++多态，可使代码看起来更自然，隐藏内部机理，强调实质。 operatorop(argument-list) // 重载+运算符 operator+() 🌈一些限制： 重","tags":null,"title":"cpp--chapter11--使用类","uri":"https://hanin97.cn/2020/11/cpp-chapter11-%E4%BD%BF%E7%94%A8%E7%B1%BB/","year":"2020"},{"content":"第10章 对象和类 目录  过程性编程和面向对象编程 类概念 如何定义和实现类 公有类访问和私有类访问 类的数据成员 类方法（类函数成员） 创建和使用类对象 类的构造函数和析构函数 const成员函数 this指针 创建对象数组 类作用域 抽象数据类型  10.1 过程性编程和面向对象编程 过程性编程首先考虑要遵循的步骤，然后考虑如何表示数据；OOP首先考虑数据\u0026ndash;如何表示数据、如何使用数据。\n10.2 抽象和类 类是一种将抽象转换为用户定义类型的C++工具，它将数据表示和操纵数据的方法组合成一个简洁的包。\n🐸小知识： 使用同一个类所创建的不同对象都有自己的存储空间，用于存储内部变量和类成员，但是同一个类的所有对象共享同一组类方法；  定义类 类规范由两部分组成：\n 类声明：以数据成员的方式描述数据部分，以成员函数的方式描述公有接口；（蓝图） 类方法定义：描述如何实现类成员函数。（细节）  // 通常将接口（类定义）放在头文件中，并将实现（类方法的代码）放在源代码文件中\r// stock.h -- Stock class interface\r// verson 00\r#ifndef STOCK00_H_\r#define STOCK00_H_\r#include \u0026lt;string\u0026gt;\r公有成员函数是程序和对象的私有成员之间的桥梁，程序不能直接访问私有数据，这被称为数据隐藏\rC++中包括了许多专门用来实现OOP方法的特性，例如\r1. 将数据表示和函数原型放在一个类声明中，来使描述成为一个整体，\r2. 隐藏数据是OOP主要的目标之一--让数据表示成为私有，使得数据只能被授权的函数访问\rclass Stock\r{\r// private可以省略，默认的\rprivate:\rstd::string company;\rlong shares;\rdouble share_val;\rdouble total_val;\r// 定义位于类声明中的函数将自动成为内联函数\rvoid set_tot() {total_val = shares * share_val;}\rpublic:\rvoid\r}\r 10.3 类的构造函数和析构函数 作用是让使用类对象能像使用标准类型一样，比如可以初始化。\n构造函数 类构造函数专门用于构造新对象、将值赋给它们的数据成员，C++已经为这些成员函数提供了名称和使用语法，需要程序员提供方法定义，程序声明对象时，将自动调用构造函数。\n🐸小知识： 当且仅当没有定义任何构造函数时，编译器才会提供默认构造函数，为类定义了构造函数后，程序员就必须为它提供默认构造函数；   构造函数的声明和定义\nStock(const string \u0026amp; co, long n = 0, double pr = 0.0);\r注意，这里的形参不能和类数据成员的名称相同，可以在数据成员名中使用m_前缀或者_后缀\rStock::Stock(const string \u0026amp; co, long n, double pr)\r{\rcompany = co;\rif (n \u0026lt; 0)\r{\rstd::cerr \u0026lt;\u0026lt; \u0026quot;Number of shares can't be megative; \u0026quot;\r\u0026lt;\u0026lt; company \u0026lt;\u0026lt; \u0026quot; shares set to 0.\\n\u0026quot;;\rshares = 0\r}\relse\rshares = n;\rshare_val = pr;\rset_tot();\r}\r// 默认构造函数，没有任何参数\rStock::Stock()\r{\rcompany = \u0026quot;no name\u0026quot;;\rshares = 0;\rshare_val = 0.0;\rtotal_val = 0.0;\r}\r// 显式\rStock food = Stock(\u0026quot;World Cabbage\u0026quot;, 250, 1.25);\r// 隐式\rStock food(\u0026quot;World Cabbage\u0026quot;, 250, 1.25);\rStock food {\u0026quot;World Cabbage\u0026quot;, 250, 1.25};\rStock food = {\u0026quot;World Cabbage\u0026quot;, 250, 1.25};\r 析构函数 析构函数完成清理工作，在类对象过期时自动被调用。 如果构造函数使用了new，则必须提供使用delete的析构函数。\n// 原型\r~Stock();\r// 定义\rStock::~Stock()\r{\rcout \u0026lt;\u0026lt; \u0026quot;Bye, \u0026quot; \u0026lt;\u0026lt; company \u0026lt;\u0026lt; \u0026quot;!\\n\u0026quot;;\r}\r const成员函数 const对象不能调用非const成员函数，声明和定义const成员函数\nvoid show() const;\rvoid stock::show() const\r 10.4 this指针 刚才的每个类成员函数都只涉及一个对象，但有时候方法可能涉及两个对象，这时候就需要用到C++的this指针，它指向用来调用成员函数的对象。\nconst Stock \u0026amp; Stock::topval(const Stock \u0026amp; s) const\r{\rif (s.total_val \u0026gt; total_val)\rreturn s;\relse\rreturn *this;\r}\r 10.5 对象数组 初始化对象数组的方案：首先使用默认构造函数创建数组元素，然后使用花括号中的构造函数创建临时对象，然后将临时对象的内容复制到响应的元素中。因此，要创建类对象数组，这个类必须有默认构造函数。\nStock mystuff[4];\rconst int STKS = 4;\rStock stocks[STKS] = {\rStock(\u0026quot;A\u0026quot;, 12.5, 20),\rStock();\rStock(\u0026quot;B\u0026quot;, 10.2, 20)\r};\r只初始化了3个，余下的1个使用默认构造函数进行初始化\r 10.6 类作用域 在类中定义的名称（如类数据成员和类成员函数名）的作用域都为整个类，只在该类中是一直的，在类外不可知，因此，不同类中的同名成员是不同的。\n作用域为类的常量\nclass Bakery\r{\rprivate:\rconst int Months = 12; // 这是不对的，因为声明类只是描述了对象的形式\rdouble costs[Months];\r}\r1. 可以使用枚举来实现\rclass Bakery\r{\rprivate:\renum {Months = 12};\rdouble costs[Months];\r}\r2. 使用static关键字\rclass Bakery\r{\rprivate:\rstatic const int Months = 12;\rdouble costs[Months];\r}\r 10.7 抽象数据类型 栈  可创建空栈 可将数据项添加到堆顶 可从栈顶删除数据项 可查看栈是否填满 可查看栈是否为空  // stack.h\r#ifndef STACK_H_\r#define STACK_H_\rtypedef unsigned long Item;\rclass Stack\r{\rprivate:\renum {MAX = 10};\rItem items[MAX];\rint top;\rpublic:\rStack();\rbool isempty() const;\rbool isfull() const;\rbool push(const Item \u0026amp; item);\rbool pop(Item \u0026amp; item);\r}l\r#endif\r ","id":18,"section":"posts","summary":"第10章 对象和类 目录 过程性编程和面向对象编程 类概念 如何定义和实现类 公有类访问和私有类访问 类的数据成员 类方法（类函数成员） 创建和使用类对象 类的","tags":null,"title":"cpp--chapter10--对象和类","uri":"https://hanin97.cn/2020/11/cpp-chapter10-%E5%AF%B9%E8%B1%A1%E5%92%8C%E7%B1%BB/","year":"2020"},{"content":"ResNeSt: Split-Attention Networks 1. 提出背景 现如今用于图像分类的网络常被用于其他任务，如目标检测、实例分割等，而在其中经常被用到的网络就是ResNet，但这毕竟是为图像分类设计的，感受野有限并且缺少通道间的交互。\n2. 解决方法 灵感来源：\n Multi-path (GoogleNet, ResNeXt) channel attention (SE-Net) Feature-map Attention (SK-Net)  ","id":19,"section":"posts","summary":"ResNeSt: Split-Attention Networks 1. 提出背景 现如今用于图像分类的网络常被用于其他任务，如目标检测、实例分割等，而在其中经常被用到的网络就是ResNet，但这毕竟是为图像","tags":["Computer vision","Classification network"],"title":"ResNeSt: Split-Attention Networks","uri":"https://hanin97.cn/2020/10/resnest/","year":"2020"},{"content":"Deep Residual Learning for Image Recognition 1. 问题背景 当时网络的深度浅，深的网络很难训练（梯度爆炸、难以拟合、退化问题：深度越深，精度趋于饱和后迅速衰减），但是网络的深度是提高网络表达能力的关键点，作者提出了一种容易优化的深度网络结构。\n已有的解决办法  normalized initialization intermediate normalization layers  但是只能训练数十层的网络，深了会出现网络退化问题。 🐸：为什么它们有助于网络拟合？2. 解决方法：残差连接 灵感来源： 图像识别中的VLAD、Fisher Vector，其他文献中的跳跃连接（比如Inception将中间层直接连到辅助分类器来处理梯度爆炸，每个Inception层由shortcut分支（指的是哪个）和一些更深的分支组成），还有高速网络，使用门控函数实现shortcut，但这是基于数据的，有参数的，并且随着深度增加，准确率并没有提升。 假设： 残差映射比无参照映射更容易优化。极端的情况：如果恒等映射是最优解，那将残差块推向零比用堆叠的非线性单元拟合恒等映射更容易。 🐸：恒等映射是最优解的话，为什么还需要这多余的恒等层呢？优点：\n 跳跃连接不增加额外的参数，也不增加计算复杂度； 跳跃连接确保随着网络深度的加深，不会出现网络退化，因为如果有恒等映射，就变成了更浅的网络，而之前的网络因为没有跳跃连接，想用非线性层拟合恒等映射很有难度。  🌈注意点： 每个stage都下采样2是通过每个stage中第一个block的3x3卷积实现的，因为有下采样，会导致跳跃连接相加时feature map的大小不一样，这里采用1x1卷积对输入进行下采样，同时，1x1还能解决每个stage的第一个block输入通道和输出通道不一致的问题，从而使其输入的特征图和输出的特征图能够相加； 后来还有个改进版的，将激活函数ReLU放到了卷积之前，相应的shortcur则不经过ReLU称为预激活残差单元，如下图：   3. 结果与总结 我们赢得了ILSVRC \u0026amp;\u0026amp; COCO 2015冠军。\n","id":20,"section":"posts","summary":"Deep Residual Learning for Image Recognition 1. 问题背景 当时网络的深度浅，深的网络很难训练（梯度爆炸、难以拟合、退化问题：深度越深，精度趋于饱和后迅速衰减），但是网络的深度是","tags":["Computer vision","Classification network"],"title":"ResNet: Deep Residual Learning for Image Recognition","uri":"https://hanin97.cn/2020/10/resnet/","year":"2020"},{"content":"Aggregated Residual Transformations for Deep Neural Networks 1. 问题背景 Inception: split-transform-merge，这种策略希望用低的计算复杂度来近似大而密集的层的表达能力。虽然它有较高的准确率，但是网络参数很难调节（每个独立transformation的滤波器的数量、大小）。\n2. 解决方法 使用相同拓扑结构的变换来组成一个模块，这样就可以减少需要手动调节的参数的数量了，更容易扩展。 🐸：提出除了网络的深度、宽度外，变换集的大小（基数）是提升网络性能的重要维度。 灵感来源：\n 多分支卷积网络； 组卷积； 网络剪枝； 集成；  下图中的三个模块是等价的，(a)为最原始版本，(b)类似Inception-ResNet，(c)使用了组卷积。 证明： 假设C=2，即每个block只有两个分支，$A_i$为最后一层卷积的权重，$B_i$为倒数第二层卷积的权重，$\u0026quot;,\u0026quot;$为水平拼接，$\u0026quot;;\u0026quot;$为垂直拼接。 (a) $output = A_1B_1 + A_2B_2 = [A_1, A_2][B_1; B_2]$ (b) $output = [A_1, A_2][B_1; B_2]$ (c) 分组卷积，易得与(b)等价 只有在block的深度大于等于3时，这种重组形式才与未重组时有所区别，如下图：\n与ResNet对比：\n3. 总结 在各个数据集和任务上进行了实验，皆可。\n","id":21,"section":"posts","summary":"Aggregated Residual Transformations for Deep Neural Networks 1. 问题背景 Inception: split-transform-merge，这种策略希望用低的计算复杂度来近似大而密集的层的表达能力。虽然它有较高","tags":["Computer vision","Classification network"],"title":"ResNeXt: Aggregated Residual Transformations for Deep Neural Networks","uri":"https://hanin97.cn/2020/10/resnext/","year":"2020"},{"content":"第9章 内存模型和名称空间 9.1 单独编译 一般将一个大型文件分解为三部分：\n 头文件：包含结构声明和使用这些结构的函数的原型（通常有函数原型、使用#define或const定义的符号常量、结构声明、类声明、模板声明、内联函数，不能将函数定义放在头文件中，当同一个程序的两个文件都包含了这个头文件时，相当于包含了同个函数的两次定义，将出错）； 源代码文件：包含与结构有关的函数的代码； 源代码文件：包含调用与结构相关的函数的代码。  🐸小知识： 在包含自己的头文件时，应使用引号而不是尖括号（首先查找当前的工作目录或源代码目录，而不是在标准位置）；  示例\n// coordin.h\r// 使用ifndef避免在同一个文件中包含同一个头文件多次\r// （当包含的文件中也包含该头文件时会出现这种情况）\r#ifndef COORDIN_H_\r#define COORDIN_H_\rstruct polar\r{\rdouble distance;\rdouble angle;\r};\rstruct rect\r{\rdouble x;\rdouble y;\r};\rpolar rect_to_polat(rect xypos);\rvoid show_polar(polar dapos);\r#endif\r// file1.cpp\r#include \u0026lt;iostream\u0026gt;\r#include \u0026quot;coordin.h\u0026quot;\rusing namespace std;\rint main()\r{\rrect rplace;\rpolor pplace;\rcout \u0026lt;\u0026lt; \u0026quot;Enter the x and y values: \u0026quot;;\rwhile (cin \u0026gt;\u0026gt; rplace.x \u0026gt;\u0026gt; rplace.y)\r{\rpplace = rect_to_polar(repalce);\rshow_polar(pplace);\rcout \u0026lt;\u0026lt; \u0026quot;Next two numbers (q to quit): \u0026quot;;\r}\rcout \u0026lt;\u0026lt; \u0026quot;Bye!\\n\u0026quot;;\rreturn 0;\r}\r// file2.cpp\r#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;cmath\u0026gt;\r#include \u0026quot;coordin.h\u0026quot;\rpolar rect_to_polar(rect xypos)\r{\rusing namespace std;\rpolar answer;\ranswer.distance = sqrt(xypos.x * xypos.x + xypos.y * xypos.y);\ranswer.angle = atan2(xypos.y, xypos.x);\rreturn answer;\r}\rvoid show_polar(polar dapos)\r{\rusing namespace std;\rconst double Rad_to_deg = 57.29577951;\rcout \u0026lt;\u0026lt; \u0026quot;distance = \u0026quot; \u0026lt;\u0026lt; dapos.distance;\rcout \u0026lt;\u0026lt; \u0026quot;, angle = \u0026quot; \u0026lt;\u0026lt; dapos.angle * Rad_to_deg;\rcout \u0026lt;\u0026lt; \u0026quot; degrees\\n\u0026quot;;\r}\r 9.2 存储持续性、作用域和链接性 存储持续性： 自动存储持续性、静态存储持续性、线程存储持续性（C++11）、动态存储持续性。 作用域（scope）： 名称在文件的多大范围内可见，分为局部和全局（名称空间作用域的特例）。 链接性（linkage）： 名称如何在不同文件间共享，分为无、外部和内部。\nint global = 1000; // 外部链接，程序的其他文件中也可以使用\rstatic int one_file = 50; // 内部链接，只在该文件中可以使用；\rint main()\r{\r...\r}\rvoid funct1(int n)\r{\rstatic int count = 0; // 无链接静态变量，只在该函数中能访问，但在程序整个运行期间都在内存中\rint llama = 0; // 自动变量\r...\r}\r 🐸小知识： 默认情况下，函数中声明的函数参数和变量的存储持续性为自动，作用域为局部，没有链接性，存储在栈中，后进先出； 关键字auto和register的演变历史（之前的用法现在不用了，但不非法）； 虽然无链接性的静态持续变量和自动变量都是只能在当前函数或代码块中访问，但是自动变量不会像静态持续变量那样在整个程序执行期间存在，适用于再生； 单定义规则：如果要在多个文件中使用外部变量，只需在一个文件中包含该变量的定义，但在使用该变量的其他所有文件中，都必须使用关键字extern声明它； 作用域解析运算符\u0026quot;::\u0026quot;，放在变量名前面表示使用变量的全局版本； 虽然使用全局变量可以不用传递参数，但这样的程序不可靠，通常情况下，应使用局部变量，外部存储适于表示常量数据； const全局变量的链接性为内部； // 第一个const防止字符串被修改，第二个字符串防止每个指针的位置被修改\rconst char * const months[12] = {\r\u0026quot;January\u0026quot;, \u0026quot;February\u0026quot;, \u0026quot;March\u0026quot;, ..., \u0026quot;December\u0026quot;\r}\r  一个文件中与另一文件中常规外部变量的同名静态外部变量将隐藏常规外部变量；  1. 说明符和限定符 a. c-v限定符\n const volatile。表明即使程序代码没有对内存单元进行修改，其值也可能发生变化，比如串口通信中，硬件可能修改其中的内容。它的作用是改善编译器的优化能力，防止这种变量被错误优化。  b. mutable 用来指出即使结构（或类）变量为const，其某个成员也可以被修改。\n2. 函数的链接性  默认情况下，函数的链接性为外部，可以在不同的文件中使用；还可以用关键字static将函数的链接性设置为内部的，在定义静态函数的文件中，静态函数将覆盖外部定义。 单定义规则也适用于非内联函数，这意味着在多文件程序中，只能有一个文件包含该函数的定义（该文件可能是库文件）； 内联函数的定义可以放在头文件中； C++查找函数的顺序：（若静态）本文件\u0026ndash;\u0026gt;所有程序文件\u0026ndash;\u0026gt;库；  3. 语言链接性 C语言和C++编译器为函数名重命名的方式不同，因此在C++中想要使用C库文件中预编译的函数时，需要指定使用C语言链接性。\nextern \u0026quot;C\u0026quot; void spiff(int); // C\rextern void spoff(int); // C++\rextern \u0026quot;C++\u0026quot; void spaff(int); // C++\r 9.3 名称空间 名称空间是为了解决大项目中的名称冲突而出现的。\nnamespace A {\rdouble pail;\rvoid fetch();\r}\r// 名称空间是开放的，即可以把名称加入到已有的名称空间中\rnamespace A {\rint haha;\r}\rnamespace B {\rint pail;\rdouble featch;\r}\r// 名称空间可以嵌套\rnamespace C\r{\rnamespace D\r{\rint a;\r...\r}\rfloat water;\r}\r// 可以给名称空间创建别名\rnamespace ABC = A::B::C;\r// 限定的名称\rA::haha\rb::pail\r// 如果不想每次使用都进行限定怎么办呢？两种办法\r// 1. using声明，使特定的标识符可用\rusing A::haha;\r// 2. using编译指令，使整个名称空间可用\rusing namespace A;\r#include \u0026lt;iostream\u0026gt; // 将名称加入名称空间std\rusing namespace std; // 使名称全局可用\r 总结 尽量将变量、函数库、类库写在名称空间中，多方便，多优雅。\n","id":22,"section":"posts","summary":"第9章 内存模型和名称空间 9.1 单独编译 一般将一个大型文件分解为三部分： 头文件：包含结构声明和使用这些结构的函数的原型（通常有函数原型、使用#de","tags":null,"title":"cpp--chapter9--内存模型和名称空间","uri":"https://hanin97.cn/2020/10/cpp-chapter9-%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%92%8C%E5%90%8D%E7%A7%B0%E7%A9%BA%E9%97%B4/","year":"2020"},{"content":"Microenvironmental Heterogeneity Parallels Breast cancer Progression: A Histology–Genomic Integration Analysis 个人总结  定量化肿瘤微环境异质性（肿瘤生态系统多样性指数[EDI]）； 将肿瘤微环境的异质性与基因和临床数据关联起来; 在高级别乳腺癌中，高EDI与差的预后紧密相关（结合TP53基因突变信息后更好），而其他类型的数据没有这种联系（如肿瘤的大小，基因组学）；但是在低级别乳腺癌中，则没有这种关联；  1. 研究背景 肿瘤内的癌细胞多样性受到广泛研究，但是有关肿瘤微环境（癌细胞和间质细胞的相互作用）的异质性的研究较少，且它与癌症的进展极度相关。\n2. 数据 1992-\u0026gt;1026，510 test（hospital1、2），516 validation（hospital3） 从每个冰冻肿瘤样本中取3段（上、中、下）来代表肿瘤的形态分析。\n3. 方法 3.2 统计方法 Kaplan-Meier estimator， log-rank test\n","id":23,"section":"posts","summary":"Microenvironmental Heterogeneity Parallels Breast cancer Progression: A Histology–Genomic Integration Analysis 个人总结 定量化肿瘤微环境异质性（肿瘤生态系统多样性指数[EDI]）； 将肿瘤微环境的异质性","tags":["Computational pathology","Breast cancer"],"title":"Microenvironmental Heterogeneity Parallels Breast cancer Progression: A Histology–Genomic Integration Analysis","uri":"https://hanin97.cn/2020/10/microenvironmental_heterogeneity_breast_yinyinyuan/","year":"2020"},{"content":"EfficientNet: Rethinking Model Scaling for Convolution Neural Networks 预备知识 FLOPS：每秒浮点运算次数 FLOPs：浮点运算数 MAC：乘积累加运算（Multiply Accumulate） 所需显存： 训练时，模型参数 + 每层输出 +（梯度参数+动量参数），括号中为训练时额外所需。对于SGD，无动量时加一倍，有动量时加两倍，对于Adam，因为有二阶动量，再加1倍。 对于卷积层：$FLOPs=(C_iK^2+C_iK^2-1)HW*C_o$，有bias时有-1，括号中第一部分为乘法运算数，第二部分为加法运算数。 对于全连接：$FLOPs=(I+I-1)*O$，有bias时有-1，括号中第一部分为乘法运算数，第二部分为加法运算数。\n1. 观点 平衡网络的深度、宽度和分辨率可以获得更好的性能。\n网络的深度： 层数 网络的宽度： 每层的通道数 网络的分辨率： 网络中特征图的分辨率（不仅取决于网络，还与输入大小有关）。 有一篇文章提出一种高分辨率的网络HRNet。[paper][code]\n2. 当前的问题 大多数工作通常指scale三个属性的其中一个，尽管scale两维、三维是有可能的，但是这需要繁琐的人工调优，并且往往得不到最优解。\n3. 贡献  提出一种利用复合系数的缩放方法来平衡网络的深度、宽度和分辨率； 结合神经架构搜索设计了新的baseline网络\u0026ndash;EfficientNets  4. 方法 问题定义： 在给定计算资源的条件下，最大化模型的准确率 假设： 随着图像分辨率的增大，网络的深度也应变大来扩大感受野以描述更大尺寸图像中相似的特征，网络的宽度也应增大以捕捉更精细的特征。 模型缩放： 不像常规的卷积网络设计那样关注网络的结构，模型缩放在不改变基准网络结构的前提下，扩展网络的深度、宽度、分辨率。尽管限定了结构不变，仍有很大的设计空间，为了进一步减少设计空间，作者限定所有层都必须以一个恒定的比例均匀缩放。复合缩放方法： $$ \\text{depth: }d=\\alpha^\\phi \\\n\\text{width: }w=\\beta^\\phi \\\n\\text{resolution: }r=\\gamma^\\phi \\\n\\text{s.t. }\\alpha \\sdot \\beta^2 \\sdot \\gamma^2 \\approx 2 \\\n\\alpha \\geq 1, \\beta \\geq 1, \\gamma \\geq 1 $$ 其中，$\\alpha, \\beta, \\gamma$可通过小规模的网格搜索得到，$\\phi$是用户指定的，FLOPs增加的倍数与$\\alpha, \\beta^2, \\gamma^2$成比例（见预备知识），这里限定$\\alpha \\sdot \\beta^2 \\sdot \\gamma^2 \\approx 2$使得对每个$\\phi$，FLOPs增加大约$2^\\phi$倍。\n步骤：\n 首先使用神经架构搜索得到EfficientNet-B0（因为好的baseline很重要）； 然后固定$\\phi$为1，以EfficientNet-B0为baseline搜索出$\\alpha=1.2, \\beta=1.1, \\gamma=1.15$； 最后固定$\\alpha, \\beta, \\gamma$，使用不同的$\\phi$得到EfficientNet-B0 - B7。  注意：以更大的模型为baseline搜索得到的$\\alpha, \\beta, \\gamma$会更好，但搜索代价及其大。\n5. 实验  以MobileNets和ResNet为baseline对比了本文的模型缩放方法和其他方法的结果。  对比了EfficientNet-B0 \u0026ndash; B7与其他模型的结果。  迁移到不同数据集上的结果。   6. 总结 又小又快。\n","id":24,"section":"posts","summary":"EfficientNet: Rethinking Model Scaling for Convolution Neural Networks 预备知识 FLOPS：每秒浮点运算次数 FLOPs：浮点运算数 MAC：乘积累加运算（Multiply Accumulate） 所需显","tags":["computer vision","classification network"],"title":"EfficientNet: Rethinking Model Scaling for Convolution Neural Networks","uri":"https://hanin97.cn/2020/10/efficientnet/","year":"2020"},{"content":"H\u0026amp;E-stained Whole Slide Image Deep Learning Predicts SPOP Mutation State in Prostate cancer 个人总结 1. 提供了一种由HE染色图像预测基因突变的方法。2. 多中心验证，且保存方法不一样（冰冻、福尔马林\u0026ndash;石蜡）。3. 利用获取的特征进行基于内容的图像检索，查找同类型患者（即SPOP突变）。4. 不需要人工选取代表区域，显著性检测定位感兴趣区域，新发现的论文 [1] Microenvironmental Heterogeneity Parallels Breast cancer Progression: A Histology–Genomic Integration Analysis. 定量肿瘤异质性（行吧，是yinyin yuan的）。\n1. 背景 如果能够从全景显微切片图像预测出SPOP基因突变的信息，将会对接下来的免疫组化、基因组学、精准医疗有重要的作用。已有的工作已经证明了基因突变和组织表型有关，例如乳腺中的E-Cadherin丢失与小叶表型有关（而不是导管表型），前列腺癌中TMPRSS2-ERG融合与许多形态学特征有关。 假设： HE染色图像的形态是由潜在基因驱动的。\n2. 数据 从TCGA的499例中选出177例适合分析的（剩余的为什么不适合分析呢？挑数据？不是，是设计了一种质控方法来筛选），其中含20例SPOP基因突变病例\n3. 方法 3.1 细胞识别和分类 TMARKER\n3.2 感兴趣区域定位方法+质控 选择依据：低倍下显著，含有最多的恶性细胞（肿瘤细胞增多与SPOP突变有关），高倍下含有最多的不正常细胞，800x800 pixels（多少倍？）\nfor all prostate adenocarcinoma patients do\rspop ← SPOP normal/mutated state as 0/1\rslide ← whole slide image of cancer biopsy\rpatches ← 75% overlap 800x800px images ← slide\rsalient_patches ← predict_saliency(patches)\rpri_tumor_patch ← max_cancer(salient_patches)\rabn_patch ← max_abnormal(pri_tumor_patch)\rif abn_patch \u0026lt; 50% blurred then\rif abn_patch \u0026lt; 50% background then\rif abn_patch \u0026lt; 50% erythrocytes then\rif abn_patch not eosin overstained then\rappend (abn_patch, spop) to data_set\rreturn data_set\r 3.3 处理样本极端不平衡的方法 13次蒙特卡洛交叉验证，保留11个验证集上acc大于0.6的模型，对这11个模型进行集成，在测试集上进行测试。整个过程重复7次，得到7个集成模型和带置信区间的结果。\nfor trial in 0, 1, 2, 3, 4 do\rtest_set ← draw(5 SPOP mutants, 5 SPOP normal)\rfor monte in 1, 2, ..., 13 in parallel do\rtrain_set ← draw(10 mutants, 10 normal)\rvalid_set ← draw(5 mutants, 5 normal)\rtestable_model ← null\rrepeat\rr50_model ← train_r50(train_set, valid_set)\rdrp5_model ← train_drp5(train_set, valid_set)\rr50_acc ← accuracy(valid_set, r50_model)\rdrp5_acc ← accuracy(valid_set, drp5_model)\rif r50_acc \u0026gt;= 0.6 then\rtestable_model ← r50_model\relse if drp5_acc \u0026gt;= 0.6 then\rtestable_model ← drp5_model\runtil 11 testable models or testable_model 6= null\rappend testable_model to testable_models\rensemble ← testable_models with ensemble averaging\rensemble_acc ← accuracy(test_set, ensemble)\rappend ensemble_acc to ensemble_accs\rappend ensemble to ensembles\rreturn (ensembles, ensemble_accs)\r 3.4 数据增强方法 the 800x800px images at high magnification were trimmed to the centermost 512x512px in 6 degree rotations, scaled to 256x256px, flipped and unflipped, then randomly cropped to 224x224 within Caffe for training.（啥意思，没看懂）\n","id":25,"section":"posts","summary":"H\u0026amp;E-stained Whole Slide Image Deep Learning Predicts SPOP Mutation State in Prostate cancer 个人总结 1. 提供了一种由HE染色图像预测基因突变的方法。2. 多中心验证，且保存方法不一样（冰冻、福尔马林\u0026ndash","tags":["Computational pathology","prostate cancer"],"title":"H\u0026E-stained Whole Slide Image Deep Learning Predicts SPOP Mutation State in Prostate cancer","uri":"https://hanin97.cn/2020/10/spop_mutant_prostate/","year":"2020"},{"content":"Non-local Neural Networks [CVPR2018] 个人总结 1. 捕获长距离依赖：即建立图像上两个有一定距离的像素之间的联系，或视频里两帧的联系，或一段话不同词的联系，更总括地说，就是在计算某个位置的响应时，考虑所有位置特征的加权（位置可以是空间的、时间的、时空的）；2. 它只考虑了同一通道不同像素间的联系，并没有考虑不同通道间的联系（像SENet那样）。","id":26,"section":"posts","summary":"Non-local Neural Networks [CVPR2018] 个人总结 1. 捕获长距离依赖：即建立图像上两个有一定距离的像素之间的联系，或视频里两帧的联系，或一段话不同词的联系，更总括地说，就是在计","tags":["computer vision"],"title":"Non-local Neural Networks","uri":"https://hanin97.cn/2020/10/non-local-neural-networks/","year":"2020"},{"content":"Computer Extracted Features from Initial H\u0026amp;E Tissue Biopsies Predict Disease Progression for Prostate cancer Patients on Active Surveillance 个人总结：\n 老特征用在新任务上，解决新问题，对比深度模型； 聚类图的画法。 scipy.cluster\r   任务： 使用提取的特征对主动监视（AS）前列腺癌患者预测疾病进展预测。\n为什么要进行这项任务： 因为与选择治愈性治疗的患者相比，主动监视（AS）前列腺癌患者的生活质量降低，焦虑和抑郁的风险增加以及疾病进展的风险增加，并且目前对AS患者使用的标准不能很好地识别疾病进展风险增加的患者，风险分层有助于对症下药。\n使用了什么方法： 定量组织形态特征（quantitative histomorphometric\u0026ndash;QH）：描述细胞核位置、形状、方向、聚类信息（216维，筛出6维）。 哪些区域的细胞核：癌区域的 细胞核分割方法：分水岭\n数据： 191，125 progressors，66 non-progressor 训练集： 30 progressors + 30 non-progressor 验证集： the remaining 131\n特征选择方法： 30次迭代，每次迭代：\n 将训练集$D_1$按标签随机分为$D_{1,A}$和$D_{1,B}$，每份分别含15个正样本，15个负样本； 在$D_{1,A}$上分别用Wilcoxon rank-sum和t-test选出6维特征，再分别训练LDA和QDA，然后在$D_{1,B}$上进行验证，记录每个模型的AUC。  保留使AUC\u0026gt;0.65的特征组合，选这些组合中出现次数排前6的特征作为最后的特征。\n","id":27,"section":"posts","summary":"Computer Extracted Features from Initial H\u0026amp;E Tissue Biopsies Predict Disease Progression for Prostate cancer Patients on Active Surveillance 个人总结： 老特征用在新任务上，解决新问题，对比深度模型； 聚类图的画法。 scipy.cluster 任务： 使用提取的特征对主动监视（","tags":["Computational pathology","prostate cancer"],"title":"Computer Extracted Features from Initial H\u0026E Tissue Biopsies Predict Disease Progression for Prostate cancer Patients on Active Surveillance","uri":"https://hanin97.cn/2020/10/cancers-prostate/","year":"2020"},{"content":"通道级别的注意力机制\n","id":28,"section":"posts","summary":"通道级别的注意力机制","tags":["Computer vision","Classification network"],"title":"SeNet","uri":"https://hanin97.cn/2020/10/senet/","year":"2020"},{"content":"第8章 函数探幽 8.1 C++内联函数 🐸小知识： 内联函数是C++为提高程序运行速度所做的一项改进，具体是怎么提高运行速度的呢？ 调用常规函数： 存储调用指令的地址\u0026ndash;\u0026gt;复制函数参数至堆栈\u0026ndash;\u0026gt;跳到标记函数起点的内存单元并执行函数代码（也许还需将返回值放入到寄存器中）\u0026ndash;\u0026gt;调回地址被保存的调用指令处。 使用内联函数： 编译器使用相应的函数代码替换函数调用，无需跳来跳去，以占用更多内存为代价。 内联函数不能递归； 使用规则：要么在函数声明前加上关键字inline，要么在函数定义前加上关键字inline，通 常省略原型，将整个定义放在本应提供原型的地方； 大函数不适合用内联，因为本身执行时间就很长； C++内联函数可以按值传递，但C语言的宏定义#define SQUARE(X) ((X)*(X))不可以按值传递;  示例：\n#include \u0026lt;iostream\u0026gt;\rinline double square(double x) {return x * x;}\rint main()\r{\rusing namespace std;\rdouble a, b;\rdouble c = 13.0;\ra = square(5.0);\rb = square(4.5 + 7.5);\rcout \u0026lt;\u0026lt; \u0026quot;a = \u0026quot; \u0026lt;\u0026lt; a \u0026lt;\u0026lt; \u0026quot;, b = \u0026quot; \u0026lt;\u0026lt; b \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;c = \u0026quot; \u0026lt;\u0026lt; c;\rcout \u0026lt;\u0026lt; \u0026quot;, c square = \u0026quot; \u0026lt;\u0026lt; square(c++) \u0026lt;\u0026lt; endl;\r}\r 8.2 引用变量 引用是一种复合类型，它是已定义的变量的别名，与原变量指向相同的值和地址； 🐸小知识： 通过将引用变量用作参数，函数将使用原始数据，而不是其副本； 引用必须在声明时将其初始化，更接近const指针; 在用作函数参数时，尽可能使用const; 返回引用时直接把返回值复制给接收变量，而不用创建临时变量（应避免返回临时变量的引 用或指针）； 返回引用的函数实际上式被引用的变量的别名；  创建引用变量\nint rats;\rint \u0026amp; rodents = rats; // 让rodents成为rats的别名\r 将引用用作函数参数\n#include \u0026lt;iostream\u0026gt;\rvoid swap(int \u0026amp; a, int \u0026amp; b);\rint main()\r{\rusing namespace std;\rint wallet1 = 300;\rint wallet2 = 350;\rswap(wallet1, wallet2);\r}\rvoid swap(int \u0026amp; a, int \u0026amp; b)\r{\rint temp;\rtemp = a;\ra = b;\rb = temp;\r}\r 临时变量、引用和const C++将在两种情况下生成临时变量（仅当参数为const时，C++才允许这样）：\n 实参的类型正确，但不是左值； 实参的类型不正确，但可以转换为正确的类型。  临时变量并不会影响原变量。\ndouble refcube(const double \u0026amp;ra)\r{\rreturn ra * ra * ra;\r}\rdouble side = 3.0;\rdouble * pd = \u0026amp;side;\rdouble \u0026amp; rd = side;\rlong edge = 5L;\rdouble lens[4] = {2.0, 5.0, 10.0, 12.0};\rdouble c1 = refcube(side);\rdouble c2 = refcube(lens[2]);\rdouble c3 = refcube(rd);\rdouble c4 = refcube(*pd); double c5 = refcube(edge) // ra is temporary variable, case 2\rdouble c6 = refcube(7.0); // ra is temporary variable, case 1\rdouble c7 = refcube(side + 10.0); // ra is temporary variable, case 1\r 右值引用 这种引用可指向右值，使用\u0026amp;\u0026amp;声明。\ndouble \u0026amp;\u0026amp; rref = std::sqrt(36.00);\rdouble j = 15.0;\rdouble \u0026amp;\u0026amp; jref = 2.0 * j * 18.5;\rstd::out \u0026lt;\u0026lt; rred \u0026lt;\u0026lt; endl;\rstd::out \u0026lt;\u0026lt; jred \u0026lt;\u0026lt; endl;\r 将引用作为函数的返回值\n// 返回string\rconst string v1(const string \u0026amp; s1, const string \u0026amp; s2)\r{\rstring temp;\rstring = s2 + s1 +s2;\rreturn temp;\r}\r// 返回string的引用\rconst string \u0026amp; v2(string \u0026amp; s1, const string \u0026amp; s2)\r{\rs1 = s2 + s1 + s2;\rreturn s1;\r}\r 对象、继承和引用\n 派生类继承基类的方法； 基类引用可以指向派生类对象。  注意下面的程序：参数os（类型为ostream \u0026amp;）可以指向ostream对象（如cout），也可以指向ostream的派生类ofstream对象（如fout）。#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;fstream\u0026gt;\r#include \u0026lt;cstdlib\u0026gt;\rusing namespace std;\rvoid file_it(ostream \u0026amp; os, double fo, const double fe[], int n);\rconst int LIMIT = 5;\rint main()\r{\rofstream fout;\rconst char * fn = \u0026quot;ep-data.txt\u0026quot;;\rfout.open(fn);\rif (!fout.is_open())\r{\rcout \u0026lt;\u0026lt; \u0026quot;Can't open \u0026quot; \u0026lt;\u0026lt; fn \u0026lt;\u0026lt; \u0026quot;. Bye.\\n\u0026quot;;\rexit(EXIT_FAILURE);\r}\rdouble objective;\rcout \u0026lt;\u0026lt; \u0026quot;Enter the focal length of your \u0026quot;\r\u0026quot;telescope objective in mm: \u0026quot;;\rcin \u0026gt;\u0026gt; objective;\rdouble eps[LIMIT];\rcout \u0026lt;\u0026lt; \u0026quot;Enter the focal lengths, in mm, of \u0026quot; \u0026lt;\u0026lt; LIMIT\r\u0026lt;\u0026lt; \u0026quot; eyepieces: \\n\u0026quot;;\rfor (int i = 0; i \u0026lt; LIMIT; i++)\r{\rcout \u0026lt;\u0026lt; \u0026quot;Eyepiece #\u0026quot; \u0026lt;\u0026lt; i + 1 \u0026lt;\u0026lt; \u0026quot;: \u0026quot;;\rcin \u0026gt;\u0026gt; eps[i];\r}\rfile_it(fout, objective, eps, LIMIT);\rfile_it(cout, objective, eps, LIMIT);\rcout \u0026lt;\u0026lt; \u0026quot;Done\\n\u0026quot;;\rcin.get();\rcin.get();\rreturn 0;\r}\rvoid file_it(ostream \u0026amp; os, double fo, const double fe[], int n)\r{\rios_base::fmtflags initial;\rinitial = os.setf(ios_base::fixed);\ros.precision(0);\ros \u0026lt;\u0026lt; \u0026quot;Focal length of objective: \u0026quot; \u0026lt;\u0026lt; fo \u0026lt;\u0026lt; \u0026quot; mm\\n\u0026quot;;\ros.setf(ios::showpoint);\ros.precision(1);\ros.width(12);\ros \u0026lt;\u0026lt; \u0026quot;f.1. eyepiece\u0026quot;;\ros.width(15);\ros \u0026lt;\u0026lt; \u0026quot;magnification\u0026quot; \u0026lt;\u0026lt; endl;\rfor (int i = 0; i \u0026lt; n; i++)\r{\ros.width(12);\ros \u0026lt;\u0026lt; fe[i];\ros.width(15);\ros \u0026lt;\u0026lt; int (fo/fe[i] + 0.5) \u0026lt;\u0026lt; endl;\r}\ros.setf(initial);\r}\r 何时使用引用参数：\n 修改调用函数中的数据对象； 提高程序的运行速度；  8.3 默认参数 🐸小知识： 通过函数原型设置默认值char * left(const char * str, int n = 1);，必须从右向左添加默认值； 在设计类时通过使用默认参数，可以减少要定义的析构函数、方法以及方法重载的数量；  8.4 函数重载（函数多态） C++在C语言的基础上新增的功能。 特征标：函数的参数列表，包括参数数目、类型、排列顺序。 🐸小知识： 默认参数允许使用不同数目的参数调用同一个函数，而函数多态允许使用多个同名的函数（那C++怎么知道是在用同一个函数的默认参数还是多态的同名的函数呢？函数重载的条件是它们的特征标不同）； 从编译器的角度考虑特征标； 没有匹配的原型并不会自动停止使用其中的某个函数，因为C++将尝试使用标准类型转换强 制进行匹配，但如果有多个函数满足强制匹配，则C++将其视为错误； 匹配函数时，并不区分const和非const变量 void dribble(char * bits);\rvoid dribble(const char *cbits);\rvoid dabble(char * bits);\rvoid drivel(const chat * bits);\rconst char p1[20] = \u0026quot;How's the weather?\u0026quot;;\rchar p2[20] = \u0026quot;How are you?\u0026quot;;\rdribble(p1); // dribble(const char *)\rdribble(p2); // dribble(char *)\rdabble(p1); // no match\rdabble(p2); // dabble(char *)\rdrivel(p1); // drivel(const char *)\rdrivel(p2); // drivel(const char *)\r  重载引用参数时，将调用最匹配的版本（参数是左值、const还是右值）； C++怎么分得清到底调用哪个  何时使用函数重载 仅当函数基本上执行相同的任务，但使用不同类型的参数时，才应使用函数重载，如果只是参数数量不同，可以考虑默认参数。\n8.5 函数模板 函数模板就是使用泛型来定义函数，其中的泛型可以用具体的类型来替换，编译器在编译的时候会将泛型替换为具体的类型。\n🐸小知识： 并非所有的模板参数都必须是模板参数类型； 在原型声明时需要加上template \u0026lt;typename AnyType\u0026gt;； 函数模板虽然试图使用泛型来简化代码，但是它仍然不能处理所有数据类型，比如常规变量 的a=b不能用于数组，a*b不能用于指针参数等，所以有必要使用不同的原型，那怎么分清使用哪个原型呢？这时候就要涉及到原型优先级：非模板函数\u0026gt;具体化\u0026gt;常规模板（见下面示例）； 既然可以隐式实例化，显式实例化有什么用呢？加快运行速度？  template \u0026lt;typename AnyType\u0026gt; // template \u0026lt;class AnyType\u0026gt;\rvoid Swap(AnyType \u0026amp;a, AnyType \u0026amp;b)\r{\rAnyType temp;\rtemp = a;\ra = b;\rb = temp;\r}\r 具体化\n// non template function prototype, job is a struct\rvoid Swap(job \u0026amp;, job \u0026amp;);\r// template prototype\rtemplate \u0026lt;typename T\u0026gt;\rvoid Swap(T \u0026amp;, T \u0026amp;);\r// explicit specialization for the job type\rtemplate \u0026lt;\u0026gt; void Swap\u0026lt;job\u0026gt;(job \u0026amp;, job \u0026amp;);\rtemplate \u0026lt;\u0026gt; void Swap(job \u0026amp;, job \u0026amp;);\r 原型优先级\n#include \u0026lt;iostream\u0026gt;\rusing namespace std;\rvoid Swap(int \u0026amp;a, int \u0026amp;b);\r// 隐式实例化（explicit instantiation）\rtemplate \u0026lt;typename T\u0026gt;\rvoid Swap(T \u0026amp;a, T \u0026amp;b);\r// 显式实例化（explicit instantiation）\rtemplate void Swap\u0026lt;int\u0026gt;(int, int);\r// 显示具体化（explicit specialization），不能和显示实例化同时使用\rtemplate \u0026lt;\u0026gt; void Swap\u0026lt;job\u0026gt;(job \u0026amp;j1, job \u0026amp;j2);\rvoid Show(job \u0026amp;j);\rstruct job\r{\rchar name[40];\rdouble salary;\rint floor;\r};\rint main()\r{\rcout.precision(2);\rcout.setf(ios::fixed, ios::floatfield);\rint i = 10, j = 20;\rcout \u0026lt;\u0026lt; \u0026quot;i, j = \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026quot;.\\n\u0026quot;;\rcout \u0026lt;\u0026lt; \u0026quot;Using compiler-generated int swapper:\\n\u0026quot;;\rSwap(i, j);\rcout \u0026lt;\u0026lt; \u0026quot;Now i, j = \u0026quot; \u0026lt;\u0026lt; i \u0026lt;\u0026lt; \u0026quot;, \u0026quot; \u0026lt;\u0026lt; j \u0026lt;\u0026lt; \u0026quot;.\\n\u0026quot;;\rjob sue = {\u0026quot;jhan\u0026quot;, 4235454.76, 7};\rjob sidney = {\u0026quot;xyhan\u0026quot;, 32424.56, 9};\rcout \u0026lt;\u0026lt; \u0026quot;Before job swapping:\\n\u0026quot;;\rShow(sue);\rShow(sidney);\rSwap(sue, sidney);\rcout \u0026lt;\u0026lt; \u0026quot;After job swapping:\\n\u0026quot;;\rShow(sue);\rShow(sidney);\rcin.get();\rreturn 0;\r}\rvoid Swap(int \u0026amp;a, int \u0026amp;b)\r{\rcout \u0026lt;\u0026lt; \u0026quot;Enter regular Swap.\\n\u0026quot;;\rint temp;\rtemp = a;\ra = b;\rb = temp;\r}\rtemplate \u0026lt;typename T\u0026gt;\rvoid Swap(T \u0026amp;a, T \u0026amp;b)\r{\rcout \u0026lt;\u0026lt; \u0026quot;Enter template Swap.\\n\u0026quot;;\rT temp;\rtemp = a;\ra = b;\rb = temp;\r}\rtemplate \u0026lt;\u0026gt; void Swap\u0026lt;job\u0026gt;(job \u0026amp;j1, job \u0026amp;j2)\r{\rcout \u0026lt;\u0026lt; \u0026quot;Enter specification Swap.\\n\u0026quot;;\rdouble t1;\rint t2;\rt1 = j1.salary;\rj1.salary = j2.salary;\rj2.salary = t1;\rt2 = j1.floor;\rj1.floor = j2.floor;\rj2.floor = t2;\r}\rvoid Show(job \u0026amp;j)\r{\rusing namespace std;\rcout \u0026lt;\u0026lt; j.name \u0026lt;\u0026lt; \u0026quot; : $\u0026quot; \u0026lt;\u0026lt; j.salary\r\u0026lt;\u0026lt; \u0026quot; on floor \u0026quot; \u0026lt;\u0026lt; j.floor \u0026lt;\u0026lt; endl;\r}\r输出：\ri, j = 10, 20.\rUsing compiler-generated int swapper:\rEnter regular Swap.\rNow i, j = 20, 10.\rBefore job swapping:\rjhan : $4235454.76 on floor 7\rxyhan : $32424.56 on floor 9\rEnter specification Swap.\rAfter job swapping:\rjhan : $32424.56 on floor 9\rxyhan : $4235454.76 on floor 7\r 🌈原型的匹配及完全匹配（难点）：\n在函数重载、函数模板、函数模板重载时，C++按以下过程决定使用哪个函数：\n 创建候选函数列表。这里放名称一样的函数和模板函数； 使用候选函数列表创建可行函数列表。这里是参数数目正确的函数； 确定是否有最佳的可行函数。如果有，就使用它，否则调用出错。  从最佳到最差的顺序如下：\n 完全匹配，但常规函数优先于模板函数； 提升转换（如char和shorts自动转换为int，float自动转换为double）； 标准转换（如int转换为char，long转换为double）； 用户定义的转换，如类声明中定义的转换。  原型的完全匹配允许一些无关紧要的转换，如下表:\n   从实参 到形参     Type Type \u0026amp;   Type \u0026amp; Type   Type[] * Type   Type (argument-list) Type (*) (argument-list)   Type const Type   Type volatile Type   Type * const Type   Type * volatile Type *    #include \u0026lt;iostream\u0026gt;\rtemplate\u0026lt;class T\u0026gt;\rT lesser(T a, T b)\r{\rreturn a \u0026lt; b ? a : b;\r}\rint lesser (int a, int b)\r{\ra = a \u0026lt; 0 ? -a : a;\rb = b \u0026lt; 0 ? -b : b;\rreturn a \u0026lt; b ? a : b;\r}\rint main()\r{\rusing namespace std;\rint m = 20;\rint n = -30;\rdouble x = 15.5;\rdouble y = 25.9;\rcout \u0026lt;\u0026lt; lesser(m, n) \u0026lt;\u0026lt; endl; // use #2\rcout \u0026lt;\u0026lt; lesser(x, y) \u0026lt;\u0026lt; endl; // use #1 with double\r// 指出应使用模板函数\rcout \u0026lt;\u0026lt; lesser\u0026lt;\u0026gt;(m, n) \u0026lt;\u0026lt; endl; // use #1 with int\r// 进行显示实例化\rcout \u0026lt;\u0026lt; lesser\u0026lt;int\u0026gt;(x, y) \u0026lt;\u0026lt; endl; // use #1 with int\rreturn 0;\r}\r 关键字decltype和后置返回类型（C++11） 在C++98中，有时无法确定编写的模板函数中用到的中间变量类型，这时候decltype就派上了用场（像numpy中的astype）。\nint x;\rdecltype(x) y;\rdecltype(x + y) xpy = x + y;\rdouble x = 5.5;\rdecltype ((xx)) r = xx; // r2 is double \u0026amp;\rdecltype (xx) w = xx; // w is double\rauto h(int x, float y) -\u0026gt; double;\rtemplate\u0026lt;class T1, class T2\u0026gt;\rauto gt(T1 x, T2 y) -\u0026gt; decltype(x + y)\r{\r...\rreturn x + y;\r}\r ","id":29,"section":"posts","summary":"第8章 函数探幽 8.1 C++内联函数 🐸小知识： 内联函数是C++为提高程序运行速度所做的一项改进，具体是怎么提高运行速度的呢？ 调用常规函数： 存储调用","tags":null,"title":"cpp--chapter8--函数探幽","uri":"https://hanin97.cn/2020/10/cpp-chapter8-%E5%87%BD%E6%95%B0%E6%8E%A2%E5%B9%BD/","year":"2020"},{"content":"第7章 函数\u0026ndash;C++的编程模块 7.1 自定义函数 使用自定义函数：定义、提供原型、调用。\n🐸小知识：\n 如果声明的返回类型为double，而函数返回一个int表达式，则该int值将被强制转换为double类型； C++的返回值类型可以是除数组外的其他任何类型，如整数、浮点数、指针，甚至可以是结构和对象（C++函数虽然不能直接返回数组，但可以将数组作为结构或对象组成部分来返回）； 函数通过将返回值复制到指定的CPU寄存器或内存单元中来将其返回，随后，调用程序将查看该内存单元； 如果函数包含多条返回语句，则函数在执行遇到的第一条返回语句后结束；  7.1.1 为什么需要原型 原型描述了函数到编译器的接口，它将函数返回值的类型以及参数的类型和数量告诉编译器。\n7.1.2 原型的语法 double cube(double x);\rvoid cheers(int);\rvoid say_hi(); // 函数没有参数\rvoid say_bye(...); // 不指定参数列表（接受可变参数）\r 函数原型不要求提供变量名，有类型列表就够了，原型中的变量名相当于占位符，因此不必与函数定义中的变量名相同。\n7.2 函数参数和按值传递 实参（参数argument）：传递给函数的值； 形参（参量parameter）：用于接收传递值得变量；\n🐸小知识：\n 如果函数的两个参数类型相同，则必须分别指定每个参数的类型； 函数内定义的变量是局部变量；  // 交替进行乘除的策略\rlong double probability(unsigned numbers, unsigned picks)\r{\rlong double result = 1.0;\rlong double n; // 为什么要将n声明为long double呢？\runsigned p;\rfor (n = numbers, p = picks; p \u0026gt; 0; n--, p--)\rresult = result * n / p;\rreturn result;\r}\r 7.3 函数和数组 🐸小知识：\n 当且仅当用于函数头或函数原型中，int * arr和int arr[]的含义才是相同的； 传递常规变量时，函数将使用该变量的拷贝，但传递数组时，函数将使用原来的数组（因为传递的其实是一个地址，这也是为什么传递数组名的同时还要传递长度）； 可在声明形参时使用关键字const防止函数无意中修改数组的内容； void f_modify(double ar[], int n);\rvoid _f_no_change(const double ar[], int n);\r   #include \u0026lt;iostream\u0026gt;\rconst int ArSize = 8;\rint sum_arr(int arr[], int n);\rint main()\r{\rusing namespace std;\rint cookies[ArSize] = {1, 2, 4, 8, 16, 32, 64, 128};\rint sum = sum_arr(cookies, ArSize);\rcout \u0026lt;\u0026lt; \u0026quot;Total cookied eaten: \u0026quot; \u0026lt;\u0026lt; sum \u0026lt;\u0026lt; endl;\rcin.get();\rreturn 0;\r}\rint sum_arr(int arr[], int n) // int sum_arr(int * arr, int n)\r{\rint total = 0;\rfor (int i = 0; i \u0026lt; n; i++)\rtotal = total + arr[i];\rreturn total;\r}\r 指针和const 🐸小知识：\n 指向const的指针，不能通过指针修改其所指向的值；指针本身是const，不能修改指针指向的位置; 尽可能指针参数声明为指向常量数据的指针，因为： a. 这样可以避免由于无意间修改数据而导致的编程错误； b. 使用const使得函数能够处理const和非const实参，否则将只能接受非const数据。  int age = 23;\r//pt指向一个const int，即*pt的值为const\rconst int * pt = \u0026amp;age; // 可以通过age修改age，但不能通过pt修改age\rconst float g_earth = 9.80;\rconst float * pe = \u0026amp;g_earth; // valid\rfloat * pm = \u0026amp;g_earth; // invalid\rfloat * const pn = \u0026amp;g_earth; // 指针本身是const，不能修改，但可使用pn修改g_earth的值\r// 简单来说：pn和*pe是const，而*pn和pe不是\r 🌈难点：仅当只有一成间接关系（如指针指向基本数据类型）时，才可以将非const地址或指针赋给const指针。\nconst int **p2;\rint *p1;\rconst int n =13;\rpp2 = \u0026amp;p1; // not allowed, but suppose it were\r*pp2 = \u0026amp;n; // valid, both const, but sets p1 to point at n\r*p1 = 10; // valid, but change const n\r 7.4 函数和二维数组 原型：int sum(int (*ar2)[4], int size);，只能接受由4列组成的数组，行数可变，等价于int sum(int ar2[][4], int size);\n7.5 函数和C-风格字符串 C-风格字符串由一系列字符组成，以空值字符结尾。（包含字符，但不以空值字符结尾的char数组只是数组，而不是字符串，因此不必将字符串长度作为参数传递给函数）\n// 处理字符串中字符的标准方式\rwhile (*str)\r{\rstatements\rstr++;\r}\r#include \u0026lt;iostream\u0026gt;\rchar * buildstr(char c, int n);\rint main()\r{\rusing namespace std;\rint times;\rchar ch;\rcout \u0026lt;\u0026lt; \u0026quot;Enter a character: \u0026quot;;\rcin \u0026gt;\u0026gt; ch;\rcout \u0026lt;\u0026lt; \u0026quot;Enter an integer: \u0026quot;;\rcin \u0026gt;\u0026gt; times;\rchar *ps = buildstr(ch, times);\rcout \u0026lt;\u0026lt; ps \u0026lt;\u0026lt; endl;\rdelete [] ps;\rcin.get();\rcin.get();\rreturn 0;\r}\rchar * buildstr(char c, int n)\r{\rchar * pstr = new char[n+1];\rpstr[n] = '\\0';\rwhile(n--)\rpstr[n] = c;\rreturn pstr;\r}\r 注意：变量pstr的作用域为buildstr函数内，因此当该函数结束时，pstr使用的内存将被释放，但new新建的字符串还在，由于函数返回了pstr的值，因此程序仍可以通过main()中的指针ps来访问新建的字符串。\n7.6 函数和结构 结构可使用按值传递，但是如果结构非常大，按值传递将增大内存要求，降低系统运行的速度，所以出现了另外两种方式：传递结构的地址和按引用传递。\n// 输入两个数字\rint x, y;\rwhile (cin \u0026gt;\u0026gt; x \u0026gt;\u0026gt; y)\r{\rstatements\r...\r}\r 7.7 函数和string、array对象 在C++中，类对象是基于结构的。\n7.8 递归 在需要将一项工作分为两项较小的、类似的工作时，递归非常有用。 递归方法有时被称为分而治之策略。\n7.9 函数指针 函数的地址：函数名 声明函数指针：\ndouble pam(int);\rdouble (*pf)(int);\rpf = pam;\rdouble x = pam(4);\rdouble y = (*pf)(4);\rdouble z = pf(4);\r// 函数指针数组\rconst double * (*pa[3])(const double *, int) = {f1, f2, f3};\r// auto只能用于单值推断\r// 使用typedef简化声明\rtypedef const double *(*p_fun)(const double *, int);\rp_fun p1 = f1;\rp_fun p3 = {f1, f2, f3};\r ","id":30,"section":"posts","summary":"第7章 函数\u0026ndash;C++的编程模块 7.1 自定义函数 使用自定义函数：定义、提供原型、调用。 🐸小知识： 如果声明的返回类型为double，而函数","tags":null,"title":"cpp--chapter7--函数","uri":"https://hanin97.cn/2020/10/cpp-chapter7-%E5%87%BD%E6%95%B0/","year":"2020"},{"content":"第6章 分支语句和逻辑运算符 6.1 if语句 #include \u0026lt;iostream\u0026gt;\rint main()\r{\rchar ch;\rstd::cout \u0026lt;\u0026lt; \u0026quot;Type, and I shall repeat.\\n\u0026quot;;\rstd::cin.get(ch);\rwhile (ch != '.')\r{\rif (ch == '\\n')\rstd::cout \u0026lt;\u0026lt; ch;\relse if (' ' == ch) // ch == ' '错误防范，防止将==写成=\rstd::cout \u0026lt;\u0026lt; ch;\relse\rstd::cout \u0026lt;\u0026lt; char(ch + 1);\rstd::cin.get(ch);\r}\rstd::cout \u0026lt;\u0026lt; \u0026quot;\\nPlease excuse the slight confusion.\\n\u0026quot;;\rstd::cin.get();\rstd::cin.get();\rreturn 0;\r}\r 6.2 逻辑表达式 逻辑OR（||, or）、逻辑AND（\u0026amp;\u0026amp;, and）、逻辑NOT（！, not）。\n🐸注意： 不要误将age \u0026gt; 17 \u0026amp;\u0026amp; age \u0026lt; 35写成17 \u0026lt; age \u0026lt; 35，这样程序不会报错，但测试结果将一直为true； 逻辑运算符||, \u0026amp;\u0026amp;的优先级比关系运算符低，但!的优先级高于所有的关系运算符和算术运算符，\u0026amp;\u0026amp;高于||； C++确保程序从左向右进行计算逻辑表达式，并在知道答案后立刻停止；  6.3 字符函数库cctype 简化一些有关字符的工作。\n这些函数的返回类型为int，但在测试表达式时，会激活bool转换。 isalpha(ch)：是否为字母； ispunct(ch)：是否为标点符号； isdigits(ch)：是否为数字（0~9）； isspace(ch)：是否为空白（换行、空格、制表符）； isalnum(ch)：是否为字母数字； iscntr(ch)：是否为控制字符； isgraph(ch)：是否为除空格之外的打印字符； islower(ch)：是否为小写字母； isprint(ch)：是否为打印字符（包括空格）； isupper(ch)：是否为大写字母； isxdigit(ch)：是否为十六进制数字； tolower(ch)：大写变小写； toupper(ch)：小写变大写；\n6.4 ?:运算符 常被用来代替if else语句，是C++中唯一一个需要3个操作数的运算符。 expression1 ? expression2 : expression3 如果expression1为true，则整个表达式的值为expression2的值，否则为expression3的值，条件表达式可以嵌套在另一个条件表达式中。\nconst cgar x[2][20] = {\u0026quot;Jason \u0026quot;, \u0026quot;at your service\\n\u0026quot;};\rconst char * y = \u0026quot;Quillstone \u0026quot;;\rfor (int i = 0; i \u0026lt; 3; i++)\rcout \u0026lt;\u0026lt; ((i \u0026lt; 2) ? !i ? x[i] : y : x[1]);\r// Jason Quillstone at your service\r 6.5 switch语句 🌈注意哦： case只是行标签，程序跳到switch中特定代码行后，将以此执行之后的所有语句，除非有明确的其他指示（如break）； 更容易从大型列表中进行选择，如果既可以使用if else if语句，又可以使用switch语句，则当选项不少于3个时，应使用switch语句，效率更高； 如果default标签被省略，而又没有匹配的标签，则程序将跳到switch后面的语句处执行。  switch (integer-expression)\r{\rcase label1 : statement(s)\rcase label2 : statement(s)\r...\rdefault : statement(s)\r}\r 6.6 break和continue语句 一个跳出本层，一个跳出本次。\n6.7 简单文件输入/输出 #include \u0026lt;iostream\u0026gt;\r#include \u0026lt;fstream\u0026gt;\rusing namespace std;\r/********** 输出 **********/\rofstream outFile;\rofstream fout;\r// outFile可使用cout可使用的任何方法\routFile.open(\u0026quot;fish.txt\u0026quot;);\rchar filename[50];\rcin \u0026gt;\u0026gt; filename;\rfout.open(filename);\rdouble wt = 125.8;\routFile \u0026lt;\u0026lt; wt;\rchar line[20] = \u0026quot;I love coding.\u0026quot;;\rfout \u0026lt;\u0026lt; line \u0026lt;\u0026lt; endl;\r/********** 输入 **********/\rifstream inFile;\rifstream fin;\rinFile.open(\u0026quot;bowling.txt\u0026quot;);\r// 检查文件是否被成功打开 #include \u0026lt;cstdlib\u0026gt;\rif (!inFile.is_open())\r{\rexit(EXIT_FAILURE);\r}\r// 检查是否为EOF\rinFile.good();\rinFile.eof();\rchar filename[50];\rcin \u0026gt;\u0026gt; filename;\rfin.open(filename);\rdouble wt;\rinFile \u0026gt;\u0026gt; wt; // 从文件中读取一个数字\rchar line[81];\rfin.getline(line, 81); // 从文本中读取一行\r...\rinFile.close();\r ","id":31,"section":"posts","summary":"第6章 分支语句和逻辑运算符 6.1 if语句 #include \u0026lt;iostream\u0026gt; int main() { char ch; std::cout \u0026lt;\u0026lt; \u0026quot;Type, and I shall repeat.\\n\u0026quot;; std::cin.get(ch); while (ch != '.') { if (ch == '\\n') std::cout \u0026lt;\u0026lt; ch; else if (' ' == ch) // ch == ' '错误防范，防止将==写成= std::cout","tags":null,"title":"cpp--chapter6--分支语句和逻辑运算符","uri":"https://hanin97.cn/2020/10/cpp-chapter6-%E5%88%86%E6%94%AF%E8%AF%AD%E5%8F%A5%E5%92%8C%E9%80%BB%E8%BE%91%E8%BF%90%E7%AE%97%E7%AC%A6/","year":"2020"},{"content":"第5章 循环和关系表达式 5.1 for循环 注意： test-expression（测试表达式）可以使用任意表达式，不是只能为真或假，C++将结果强制转换为bool类型； for循环是入口条件循环，意味着在每轮循环之前，都将计算测试表达式的值； for语句的控制部分使用3个表达式，而在C++中，任何值或任何有效的值和运算符的组合都是表达式（表达式加分号成为语句，但语句去掉分号不一定是表达式），C++将赋值表达式的值定义为左侧成员的值； 完整表达式\u0026ndash;表达式语句中的表达式部分，while循环中检测条件的表达式。任何完整的表达式末尾都是一个顺序（点），C++确保执行下一跳语句前，完整表达式的所有操作被执行完毕； 逗号表达式的值是最后一部分的值，逗号运算符的优先级是最低的； 循环体必须是一条语句，该语句可以是复合语句或者用逗号运算符合并出的语句，使用像python那样的缩进是不行的，那样只有第一条语句被当作循环体； 复合语句中定义的变量只在该复合语句内有效；  for循环语法\n#include \u0026lt;iostream\u0026gt;\rint main()\r{\rusing namespace std;\rint i;\r// init; test; update\rfor (i = 0; i \u0026lt; 5; i++) // for (int i = 0; i \u0026lt; 5; i++)\rcout \u0026lt;\u0026lt; \u0026quot;You are so smart!\\n\u0026quot;;\rcout \u0026lt;\u0026lt; \u0026quot;Stop.\\n\u0026quot;;\rreturn 0;\r}\r// 不完整的表达式，下式中的4 + x++\ry = (4 + x++) + (6 + x++);\r// 逗号运算符\ra = (i = 20, j = 2 * i); // a = 40, i = 20, j = 40\ra = i = 20, j = 2 * i; // a = 20, i = 20, j = 40\r 复合语句，逗号运算符合并语句\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;string\u0026gt;\rint main()\r{\rusing namespace std;\rcout \u0026lt;\u0026lt; \u0026quot;Enter a word: \u0026quot;\rstring word;\rcin \u0026gt;\u0026gt; word;\rchat temp;\rint i, j;\rfor (j = 0, i = word.size() - 1; j \u0026lt; i; --i, ++j)\r{\rtemp = word[i];\rword[i] = word[j];\rword[j] = temp;\r}\rcout \u0026lt;\u0026lt; word \u0026lt;\u0026lt; \u0026quot;\\nDone\\n\u0026quot;;\rreturn 0;\r}\r 5.2 while循环 注意： while循环是一种入口条件循环；  while循环实现延时\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;ctime\u0026gt;\rint main()\r{\rusing namespace std;\rcout \u0026lt;\u0026lt; \u0026quot;Enter the delay time, in seconds: \u0026quot;;\rfloat secs;\rcin \u0026gt;\u0026gt; secs;\rclock_t delay = secs * CLOCKS_PER_SEC;\rcout \u0026lt;\u0026lt; \u0026quot;staring\\a\\n\u0026quot;;\rclock_t start = clock();\rwhile (clock() - start \u0026lt; delay)\r;\rcout \u0026lt;\u0026lt; \u0026quot;done \\a\\n\u0026quot;;\rcin.get();\rcin.get();\rreturn 0;\r}\r 类型别名\n// 使用预处理器\r#define BYTE char\r// 使用关键字typedef（推荐，可用于声明一系列变量）\rtypedef char byte;\rtypedef char * byte_pointer; // pointer to char type\r 5.3 do while循环 注意： do while循环是一种出口条件循环； 适合必须先获得输入才能进行测试的情况；  int n;\rdo\r{\rcin \u0026gt;\u0026gt; n;\r} while (n != 7);\r 5.4 基于范围的for循环（C++11） double prices[5] = {4.99, 10.99, 2.32};\rfor (double x : prices)\rcout \u0026lt;\u0026lt; x \u0026lt;\u0026lt; std::endl;\r// \u0026amp;表明x是一个引用变量，这种声明让接下来的代码能够修改数组的内容\rfor (double \u0026amp;x : prices)\rx = x * 0.80;\r 5.5 循环和文本输入 注意： 原始cin忽略空格和换行符； cin.get(char)可以读取空格；  // 使用原始cin，忽略空格和换行符\rchar ch;\rint count = 0;\rcout \u0026lt;\u0026lt; \u0026quot;Enter characters; enter # to quit:\\n\u0026quot;;\rcin.get(ch);\rwhile (ch != '#')\r{\rcout \u0026lt;\u0026lt; ch;\r++count;\rcin.get(ch);\r}\rcout \u0026lt;\u0026lt; endl \u0026lt;\u0026lt; count \u0026lt;\u0026lt; \u0026quot;characters read\\n\u0026quot;;\rreturn 0;\r// cin.fail()检测文件尾条件（EOF）\r// while(!cin.fail()) \u0026lt;=\u0026gt; while(cin) \u0026lt;=\u0026gt; while(cin.get(ch))\r// cin.get(char)的返回值为cin\r// 下面两程序等价\rchar ch;\rcin.get(ch); // EOF可能与char类型不兼容\rwhile (cin.fail() == false)\r{\rcout \u0026lt;\u0026lt; ch;\r++count;\rcin.get(ch);\r}\rint ch;\rch = cin.get();\rwhile (ch != EOF)\r{\rcout.put(ch);\r++count;\rch = cin.get();\r}\rint ch;\rwhile((ch = cin.get()) != EOF)\r{\rcout.put(char(ch));\r++count;\r}\r 小知识点：如果留心，会发现cin.get()有好多种，比如cin.get(); cin.get(ch); cin.get(name, ArSize);为什么名字一样，但是可以传入不同的参数呢？这是因为函数重载，它允许创建多个同名函数，条件是它们的参数列表不同。\n5.6 嵌套循环和二维数组 C++没有提供二维数组类型，但用户可以创建每个元素本身都是数组的数组\n二维数组\nint btus[5] = {23, 26, 24, 31, 28};\rint maxtemps[4][5] = {\r{96, 100, 87, 101, 105},\r{2, 3, 4, 5, 7},\r{4, 4, 6, 7, 9},\r{45, 345, 234, 21, 321}\r};\rconst char * cities[3] = {\r\u0026quot;Nanjing\u0026quot;,\r\u0026quot;Beijing\u0026quot;,\r\u0026quot;lianyungang\u0026quot;\r};\r ","id":32,"section":"posts","summary":"第5章 循环和关系表达式 5.1 for循环 注意： test-expression（测试表达式）可以使用任意表达式，不是只能为真或假，C++将结果强制转","tags":null,"title":"cpp--chapter5--循环和关系表达式","uri":"https://hanin97.cn/2020/10/cpp-chapter5-%E5%BE%AA%E7%8E%AF%E5%92%8C%E5%85%B3%E7%B3%BB%E8%A1%A8%E8%BE%BE%E5%BC%8F/","year":"2020"},{"content":"第4章 复合类型 2020-10-15\n最深远的复合类型是类。\n 4.1 数组 4.1.1 声明方法 typeName arrayName[arraySize];\rshort months[12]; //从0开始编号\r 注意： 编译器不会检查使用的下标是否有效，当下标超出数组范围时，编译器并不会报错，但是程序运行后，会引发问题，也可能导致程序异常终止; 存储多个同类型的值； 在内存中是连续的。  4.1.2 初始化规则  只有在定义数组时才能使用初始化，不能先声明再直接对整个数组赋值，但是可以使用下标分别给数组中的元素赋值； int card[4] = {3, 6, 8, 10}; // okay\rint hand[4]; // okay\rhand[4] = {5, 6, 7, 9}; // not allowed\rhand = cards; // not allowed\rhand[0] = 3; // okay\r  初始化数组时，提供的值可以少于数组的元素数目，剩余的会被编译器自动设置为0，这在将数组中所有元素都初始化为0时很有用； 如果初始化数组时方括号内（[]）为空，C++编译器将会自动统计元素个数（在初始化数组时通常别这样做，但初始化字符串时这样很方便）； 初始化数组时，可省略等号（=）（C++11）； 初始化数组时，可不在大括号内包含任何东西，默认为0（C++11）； 初始化时禁止缩窄转换（C+11）。 ps： C++标准模板库提供了数组的替代品\u0026ndash;模板类vector，C++11新增了模板类array，比内置复合类型数组更复杂、更灵活。 具体怎么灵活呢？   4.2 字符串 4.2.1 字符串初始化 注意： 字符串在内存中也是连续的，可以存储在char数组中； C-风格字符串以空字符（null character）结尾，被写作\\0，其ASCII码为0，用来标记字符串的结尾，不是空格； 使用引号括起的字符串常量，隐式地包括结尾的空字符； ''和\u0026quot;\u0026quot;的区别很大，一个是字符常量，一个是字符串常量，如\u0026quot;S\u0026quot;表示两个字符（字符S和\\0）组成的字符串。 char dog[8] = {'b', 'e', 'a', 'u', 'x', ' ', 'I', 'I'}; // not a string\rchar cat[8] = {'f', 'a', 't', 't', 'e', 's', 's', 'a', '\\0'}; // a string\rchar fish[] = \u0026quot;Bubbles\u0026quot;; // a string\rchar shirt_size = \u0026quot;S\u0026quot;; // illegal type mismatch\r   4.2.2 字符串拼接 😄任何两个由空白（空格、制表符、换行符）分隔的字符串常量都将自动拼接成一个，第一个字符串的\\0字符将被第二个字符串的第一个字符取代。\n4.2.3 在数组中使用字符串 string.cpp\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;cstring\u0026gt; // for strlen() function\rint main()\r{\rusing namespace std;\rconst int Size = 15;\rchar p1[Size];\rchar p2[Size] = \u0026quot;却又吹得让它慌张\\n\u0026quot;;\rcout \u0026lt;\u0026lt; \u0026quot;你问风为什么托着候鸟飞翔， \u0026quot; \u0026lt;\u0026lt; p2;\rcin \u0026gt;\u0026gt; p1;\rcout \u0026lt;\u0026lt; \u0026quot;却也湿透她的衣裳\\n\u0026quot;;\rcout \u0026lt;\u0026lt; \u0026quot;你问我为什么还是不敢放下， \u0026quot; \u0026quot;明知听不到回答\\n\u0026quot;;\r}\r 注意： strlen()函数返回存储在数组中的字符串的长度，只计算可见的字符，不包含空字符； sizeof()运算符统计整个数组的长度。  4.2.4 字符串的输入 insre1.cpp\n#include \u0026lt;iostream\u0026gt;\rint main()\r{\rusing namespace std;\rconst int ArSize = 20;\rchar name[ArSize];\rchar dessert[ArSize];\rcout \u0026lt;\u0026lt; \u0026quot;Enter your name:\\n\u0026quot;;\rcin \u0026gt;\u0026gt; name;\rcout \u0026lt;\u0026lt; \u0026quot;Enter your favorite dessert:\\n\u0026quot;;\rcin \u0026gt;\u0026gt; dessert;\rcout \u0026lt;\u0026lt; \u0026quot;I have some delicious \u0026quot; \u0026lt;\u0026lt; dessert;\rcout \u0026lt;\u0026lt; \u0026quot; for you, \u0026quot; \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot;.\\n\u0026quot;;\rreturn 0;\r}\r  Enter your name: Jineng Dreeb Enter your favorite dessert: I have some delicious Dreeb for you, Jineng.\n 在本例中，都没有对“Enter your favorite dessert:”作出反应，程序就已经显示出来了，为什么呢？这关系到cin如何确定已完成对字符串的输入。 由于不能通过键盘输入空字符，因此cin使用空白（空格、制表符、换行符）来确定字符串的结束位置，cin在获取字符数组时只读取一个单词，然后将该字符串放在数组中，并自动在结尾添加空字符，后面的单词留在输入队列中，等待下一次读取。\n4.2.5 每次读取一行字符串输入 C++常使用指针来处理字符串。\n注意： cin.getline()每次读取一行，读到换行符，随后丢弃换行符，保存时将换行符替换为空字符； cin.get()读到换行符，将换行符留在队列中； cin.get()用来检查错误更方便，通过读取下一个字符是不是换行符可以知道之前读的字符串是否超出了数组的长度； cin.get() 在读取空行后将设置失效位（failbit），接下来的输入将会被阻断（直接回车，程序直接退出了），但可用cin.clear()来恢复输入； 当输入的字符串比分配空间长时，都会把余下的字符留在输入队列中，而 cin.getline() 还会设置失效位，并关闭后面的输入（直接回车，程序直接退出了）。  以下语句等价：\ncin.getline(name1, ArSize).getline(name2, ArSize);\rcin.get(name1, ArSize).get().getline(name2, ArSize).get(); // cin.get()读取下一个字符（即使是换行符）\r 4.2.6 混合输入字符串和数字 如下程序会出现问题，用户没有输入地址的机会。因为cin读取年份后，将回车键生成的换行符留在了输入队列，getline会把换行符当作空行赋给address数组，可以在cin后加get。\nint year;\rcin \u0026gt;\u0026gt; year;\rchar address[80];\rcin.getline(address, 80);\r  4.3 String类 特点：\n 自动调整长度； 使字符串操作更容易。  4.3.1 初始化 string str1;\rcin \u0026gt;\u0026gt; str1; // str1开始长度为0，但将输入读取到str1中时，将自动调整str1长度\rstring str2 = \u0026quot;panther\u0026quot;;\r// C++11\rchar first[] = {\u0026quot;JHAN\u0026quot;};\rchar second[] {\u0026quot;JHAN\u0026quot;};\rstring third = {\u0026quot;JHAN\u0026quot;};\rstring fourth {\u0026quot;JHAN\u0026quot;};\r 4.3.2 赋值、拼接和附加 不能将一个数组赋给另一个数组，但是可以将一个string对象赋给另一个string对象。\nstring str3;\rstr3 = str1 + str2; // 拼接str1和str2给str3，cstring strcpy （这个没法自动调整长度，可用stmcpy接受第三个参数）\rstr1 += str2; // 把str2加到str1后面，cstring strcat （这个没法自动调整长度，可用stmcat接受第三个参数）\rstring str;\rgetline(cin, str);\r 4.3.3 原始字符串（C++11） cout \u0026lt;\u0026lt; R\u0026quot;(jhan \u0026quot;jhan\u0026quot; \u0026quot;\\n\u0026quot;)\u0026quot; \u0026lt;\u0026lt; '\\n';\rcout \u0026lt;\u0026lt; R\u0026quot;+*(\u0026quot;(jhan)\u0026quot;, jhan)+*\u0026quot; \u0026lt;\u0026lt; '\\n';\r  jhan \u0026ldquo;jhan\u0026rdquo; \u0026ldquo;\\n\u0026rdquo; \u0026quot;(jhan)\u0026quot;, jhan\n 4.4 结构简介 特点：\n 存储多种类型的数据； 使用运算符（.）来访问各个成员； 外部声明（位于函数外面）和内部声明（位于main()函数内部）的作用域，若内部声明和外部声明名称重复，则在函数内部以内部声明为准； 对结构的操作与内置类型相似（例如作为参数传递，作为返回值，成员赋值）。  // 结构描述：\rstruct inflatable\r{\rchar name[20];\rfloat volume;\rdouble price;\r};\r// 声明结构变量\rstruct inflatable goose; // C需要使用关键字struct\rinflatable vincent; // C++可以省略关键字struct\r// 初始化结构变量\rinflatable guest = {\r\u0026quot;jhan\u0026quot;,\r1.88,\r29.99\r}; // 有些实现需要用 static inflatable guest，为什么呢？\rinflatable duck {\u0026quot;yuli\u0026quot;, 0.12, 9.98};\rinflatable duck {}; // 都被设置为零\r// 可以同时完成定义结构和创建结构变量的工作\rstruct perks\r{\rint key_number;\rchar car[12];\r} mr_smith, ms_jones;\r// 甚至可以同时初始化\rstruct perks\r{\rint key_number;\rchar car[12];\r} mr_glitz =\r{\r7,\r\u0026quot;jhan\u0026quot;\r};\r// 还可以声明没有名称的结构类型，但需要同时定义变量\rstruct\r{\rint x;\rint y;\r} position;\r/******** 结构数组 ********/\rinflatable gifts[100]; // array of 100 inflatable structures\rinflatable guests[2] = {\r{\u0026quot;Bambi\u0026quot;, 0.5, 21.99},\r{\u0026quot;Godzilla\u0026quot;, 2000, 565.99}\r};\r// 位字段，指定占用特定位数的结构成员（使得创建与某个硬件设备上的寄存器对应的数据结构特别方便）\r// 字段的类型应为整型或枚举\rstruct torgle_register\r{\runsigned int SN : 4; // 4 bits for SN value\runsigned int : 4; // 4 bits unused\rbool goodIn : 1;\rbool goodTorgle : 1;\r};\rtorgle_register tr = {14, true, false};\r 4.5 共用体 特点：\n 能够存储不同类型的数据类型，但只能同时存储其中一种类型； 共用体的长度为其最大成员的长度（那还怎么节省空间？）  union one4all\r{\rint int_val;\rlong long_val;\rdouble double_val;\r};\rstruct widgrt\r{\rchar brand[20];\rint type;\runion id\r{\rlong id_num;\rchar id_char[20];\r} id_var;\r};\r...\rwidget prize;\r...\rif (prize.type == 1)\rcin \u0026gt;\u0026gt; prize.id_val.id_num;\relse\rcin \u0026gt;\u0026gt; prize.id_var.id_char;\r// 匿名共用体，共用体成员被视为变量prize的成员，它们的地址相同，不需要中间标识符id_val\rstruct widgrt\r{\rchar brand[20];\rint type;\runion\r{\rlong id_num;\rchar id_char[20];\r};\r};\r...\rwidget prize;\r...\rif (prize.type == 1)\rcin \u0026gt;\u0026gt; prize.id_num;\relse\rcin \u0026gt;\u0026gt; prize.id_char;\r// 可以使用one4all变量来存储int、long或double，条件是在不同的时间进行\rone4all pail;\rpail.int_val = 15;\rpail.double_val = 1.38;\r 作用（使用场景）：\n 疑问: 到底怎么节省的？从下面的程序运行结果来看，所占空间并没有随使用的变量数据类型而动态变化啊。常用于节省内存。当数据项使用两种或更多种格式（但不会同时使用）时，可节省空间。  #include \u0026lt;iostream\u0026gt;\runion test\r{\rint a;\rdouble b;\r};\rint main()\r{\rusing namespace std;\rtest jhan;\rjhan.a = 4;\rcout \u0026lt;\u0026lt; \u0026quot;size of int is \u0026quot; \u0026lt;\u0026lt; sizeof(int) \u0026lt;\u0026lt; endl; // 4\rcout \u0026lt;\u0026lt; \u0026quot;size of double is \u0026quot; \u0026lt;\u0026lt; sizeof(double) \u0026lt;\u0026lt; endl; // 8\rcout \u0026lt;\u0026lt; \u0026quot;size of jhan is \u0026quot; \u0026lt;\u0026lt; sizeof(jhan) \u0026lt;\u0026lt; endl; // 8\rcout \u0026lt;\u0026lt; \u0026quot;size of test is \u0026quot; \u0026lt;\u0026lt; sizeof(test) \u0026lt;\u0026lt; endl; // 8\rjhan.b = 8.23;\rcout \u0026lt;\u0026lt; \u0026quot;size of jhan is \u0026quot; \u0026lt;\u0026lt; sizeof(jhan) \u0026lt;\u0026lt; endl; // 8\rcout \u0026lt;\u0026lt; \u0026quot;size of test is \u0026quot; \u0026lt;\u0026lt; sizeof(test) \u0026lt;\u0026lt; endl; // 8\rcin.get();\r}\r 4.6 枚举 作用：\n 创建符号常量，代替const； 枚举量是整型，可被提升为int类型，但int类型不能自动转换为枚举类型; 在算术表达式中，枚举将被转换为整数，得到的类型为int，不能直接赋给枚举变量  // 让spectrum成为新类型的名称；spectrum被成为枚举（enumeration）；\r// 将red、orange、yellow等作为符号常量，对应整数值0~7，这些常量叫作枚举量\renum spectrum {red, orange, yellow, green, blue, violet, indigo};\renum {red, orange, yellow, green, blue, violet, indigo};\r// 一些限制\rspectrum band;\rband = blue; // valid\rband = 2000; // invalid\rband = orange + red; // invalid\rint color = blue; // valid, promoted to int\rband = 3; // invalid\rband = spectrum(3); // valid\rband = spectrum(4003); // undefined, result not sure\rcolor = 3 + red; // valid\r// 设置枚举量的值\renum bits{one = 1, two = 2, four = 4, eight = 8};\rbits myflag;\rmyflag = bits(6); // valid\r// first = 0, third = 101\renum bigstep{first, second = 100, third};\r// zero, null = 0; one, numero_uno = 1\renum {zero, null = 0, one, numero_uno = 1};\r// 枚举的取值范围，允许在取值范围内使用强制类型转换将整数值给枚举变量\r上限：大于最大值的最小的2的幂减1\r下限：若最小值不小于0，则下限为0；否则。小于最小值的最大的2的幂（加负号）加1\r 4.7 指针和自由空间 计算机程序在存储数据时必须跟踪的3种基本属性：\n 信息存储在何处； 存储的值为多少； 存储的信息是什么类型。  达到这种目的的一种策略：定义简单变量，指出值得类型和符号名，让程序为值分配内存，并在内部跟踪该内存单元，这时值是指定的量，而地址为派生量。\n为什么要使用指针？ 使程序能够在运行阶段动态分配内存（配合new），节省空间，而不是在编译阶段就将所需的空间按可能的最大值确定下来。这时地址为指定的量，而值为派生量。\n特点：\n 改变指针所指的地址处的值，此处的变量值也变； 尽管指针有许多不同的类型，但是所有指针变量本身的长度都是一样的，只是它们指向的数据类型不同； 指针名可以用来加减，实现地址偏移（一次偏移一个类型长度）；  注意点：\n 一定要在对指针应用解除引用运算符（*）之前，将指针初始化为一个确定的、适当的地址，错误示范：long * fellow; *fellow = 223323;地址不明确，可能导致一些最隐匿、最难以跟踪的bug； 地址本身只指出了对象存储地址的开始； 内存耗尽，new引发异常； new创建数组时，返回第一个元素的地址给指针； 只有在使用了new后，才能使用delete，将它用于new分配的内存； 不能使用sizeof运算符来确定动态分配的数组包含的字节数，但是程序确实跟踪了分配的内存量（只是信息不公用）  // 指针与地址\r#include \u0026lt;iostream\u0026gt;\rint main()\r{\rusing namespace std;\rint a = 6;\r// *运算符两边的空格是可选的\r// C: int *ptr;\r// C++: int* ptr;\rint * p_a;\r// 下面的声明创建一个指针（p1）和一个int变量（p2），对每个指针变量名，都需要使用一个*\rint* p1, p2\rp_a = \u0026amp;a;\r/*\ra == *p_a\r\u0026amp;a == p_a\r*/\r*p_a = *p_a + 1; // a = 7\r// 指针和数字\rint * pt;\rpt = 0XB8000000; // type mismatch\rpt = (int *) 0XB8000000; // type now match\r// 使用new来分配内存（在运行阶段分配未命名的内存以存储值）\r// 常规变量声明从栈（stack）分配内存，new从堆（heap）或自由存储区（free store）分配内存\rint * pn = new int;\r*pn = 2020;\r// 使用delete释放内存\rint* ps = new int;\rint* pq = ps;\rcout \u0026lt;\u0026lt; \u0026quot;ps: \u0026quot; \u0026lt;\u0026lt; ps \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;pq: \u0026quot; \u0026lt;\u0026lt; pq \u0026lt;\u0026lt; endl; // pd == ps\rdelete pq;\r/* 如果程序只需要小型数据对象，那直接声明简单变量比使用new和指针更简单，\r对于大型数据，应使用new。\r在编译时为数组分配内存空间称为静态联编（static binding），\r在运行时选择创建并选择长度称为动态联编（dynamic binding）。\r*/ // 使用new创建动态数组\r// new返回第一个元素的地址，该地址被赋给指针psome\rint * psome = new int [10]; // 还不是占了10个int？？？\rdelete [] psome;\r// 指针名可以用来加减，地址偏移\rdouble * p3 = new double [3];\rp3[0] = 0.2;\rp3[1] = 0.5;\rp3[2] = 0.8;\rp3 = p3 + 1; // p3[0] = 0.5\rp3 = p3 - 1; // p3[0] = 0.2\r}\r 4.8 指针、数组、指针算术 从面的例子中可以看出，我们可以像操作数组一样操作指针，原因在于指针算术和C++内部处理数组的方式。\n知识点：\n 整数变量加1后，其值将增加1；将指针变量加1后，增加的量等于它指向的类型的字节数； C++将数组名解释为地址； 对数组应用sizeof得到的是数组的长度，对指针应用sizeof得到的是指针的长度； \u0026amp;数组名得到的是整个数组的地址，虽然cout输出与数组名的结果相同，但是它们加1后的结果不一样； 数组指针：假设数组长度为20，指向数组的指针double (*pas)[20] = \u0026amp;arrayName，使用double *pas = \u0026amp;arrayName会报错；指针数组double *pas[20]，数组的元素是指针； 在cout和多数C++表达式中，char数组名、char指针以及用引号括起的字符串常量都被解释为字符串第一个字符的地址； 应使用strcpy()或strncpy()将字符串赋给数组，而不是赋值运算符； 不能使用=将一个字符串赋给另一个字符数组或字符指针；  数组与指针\n#include \u0026lt;iostream\u0026gt;\rint main()\r{\rusing namespace std;\rdouble wages[3] = {100.0, 200.0, 300.0};\rshort stacks[3] = {3, 2, 1};\r// 两种获取数组地址的方式\rdouble * pw = wages;\rshort * ps = \u0026amp;stacks[0]; // 这也说明数组的地址是第一个元素的起始地址\rcout \u0026lt;\u0026lt; \u0026quot;wages: \u0026quot; \u0026lt;\u0026lt; wages \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;\u0026amp;wages: \u0026quot; \u0026lt;\u0026lt; \u0026amp;wages \u0026lt;\u0026lt; endl; // 数组的地址，double (*pas)[20] = \u0026amp;tell\rcout \u0026lt;\u0026lt; \u0026quot;wages + 1: \u0026quot; \u0026lt;\u0026lt; wages + 1 \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;\u0026amp;wages + 1: \u0026quot; \u0026lt;\u0026lt; \u0026amp;wages + 1 \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;wages[0]: \u0026quot; \u0026lt;\u0026lt; wages[0] \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;*wages: \u0026quot; \u0026lt;\u0026lt; *wages \u0026lt;\u0026lt; endl;\rcout \u0026lt;\u0026lt; \u0026quot;*(\u0026amp;(wages[0])): \u0026quot; \u0026lt;\u0026lt; *(\u0026amp;(wages[0])) \u0026lt;\u0026lt; endl;\rcin.get();\r/*\rwages: 0x70fdf0\r\u0026amp;wages: 0x70fdf0\rwages + 1: 0x70fdf8\r\u0026amp;wages + 1: 0x70fe08\rwages[0]: 100\r*wages: 100\r*(\u0026amp;(wages[0])): 100\r*/\r}\r 使用new创建动态结构 创建动态结构时，不能将成员运算符句点用于结构名，因为这种结构没有名称，只是知道它的地址。这种情况有个专门的运算符-\u0026gt;。\nstruc things\r{\rint good;\rint bad;\r};\rthings grubnose = {3, 453};\rthings *pt = \u0026amp;grubnose;\r// grubnose.good == pt-\u0026gt;good == (*pt).good\r 一个使用new和delete节省内存的示例\n#include \u0026lt;iostream\u0026gt;\r#include \u0026lt;cstring\u0026gt;\rusing namespace std;\rchar * getname(void);\rint main()\r{\rchar *name;\rname = getname();\rcout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot; at \u0026quot; \u0026lt;\u0026lt; (int *) name \u0026lt;\u0026lt; endl;\rdelete [] name;\rname = getname();\rcout \u0026lt;\u0026lt; name \u0026lt;\u0026lt; \u0026quot; at \u0026quot; \u0026lt;\u0026lt; (int *) name \u0026lt;\u0026lt; endl;\rdelete [] name;\rcin.get();\rcin.get();\rreturn 0;\r}\rchar * getname()\r{\rchar temp[80];\rcout \u0026lt;\u0026lt; \u0026quot;Enter last name: \u0026quot;;\rcin \u0026gt;\u0026gt; temp;\rchar * pn = new char[strlen(temp) + 1];\rstrcpy(pn, temp);\rreturn pn;\r}\r 自动存储、静态存储、动态存储 C++的3中管理数据内存的方式，C++11新增了第四种类型：线程存储。\n 自动存储 生命周期： 在函数内部定义的常规变量使用自动存储空间，被称为自动变量，意味着它在所属的函数被调用时自动产生，该函数结束时消亡。实际上，自动变量是一个局部变量，其作用域为包含它的代码块。 存储位置： 通常存储在栈中，后进先出（LIFO）。 静态存储 生命周期： 整个程序执行期间都存在。使变量成为静态的两种方式：在函数外定义它；在声明时使用关键字static。 动态存储 使用new和delete实现。它们管理了一个内存池，这在C++中被称为自由存储空间（free store）或堆（heap），该内存池与用于静态变量和自动变量的内存是分开的。 注意：要养成同时使用new和delete的习惯，否则容易发生内存泄漏，C++智能指针有助于自动完成这种任务。  指向指针的指针\n 为什么跟结构有关的指针前面要加关键字const呢？  struct person\r{\rint age;\r};\rperson p1, p2, p3;\rconst person * aim[3] = {\u0026amp;p1, \u0026amp;p2, \u0026amp;p3};\rconst person ** ppa = aim;\rauto ppb = aim;\r 4.9 数组的替代品：模板类vector和array 模板类vector vector\u0026lt;typeName\u0026gt; vt(n_elem); 类似于string类，是一种动态数组。\n#include \u0026lt;iostream\u0026gt;\r...\rusing namespace std;\rvector\u0026lt;int\u0026gt; vi; // create a zero-size array of int\rint n;\rcin \u0026gt;\u0026gt; n;\rvector\u0026lt;double\u0026gt; vd(n); // create an array of n doubles\r 模板类array（C++11） array\u0026lt;typeName, n_elem\u0026gt; arr;\n注意： 只有在C++11中，才可以将列表初始化用于vector和array对象，其他情况只能一个个赋值； array对象和数组存储在相同的内存区域（栈），vector存储在另一区域（自由存储区或堆）； 不允许使用负索引，但使用中括号时C++不会检查，可以使用at成员函数来捕获非法索引。  ","id":33,"section":"posts","summary":"第4章 复合类型 2020-10-15 最深远的复合类型是类。 4.1 数组 4.1.1 声明方法 typeName arrayName[arraySize]; short months[12]; //从0开始编号 注意： 编译器不会检查使用的下标是否有效，当下标超出数组范围时，","tags":null,"title":"cpp--chapter4--复合类型","uri":"https://hanin97.cn/2020/10/cpp-chapter4-%E5%A4%8D%E5%90%88%E7%B1%BB%E5%9E%8B/","year":"2020"},{"content":"1 强制类型转换 // typecast.cpp -- forcing type changes\r#include \u0026lt;iostream\u0026gt;\rint main()\r{\rusing namespace std;\rint auks, bats, coots;\rauks = 19.99 + 11.99;\rbats = (int) 19.99 + (int) 11.99; // old C syntax\rcoots = int (19.99) + int (11.99); // new C++ syntax\rcout \u0026lt;\u0026lt; \u0026quot;auks = \u0026quot; \u0026lt;\u0026lt; auks \u0026lt;\u0026lt; \u0026quot;, bats = \u0026quot; \u0026lt;\u0026lt; bats;\rcout \u0026lt;\u0026lt; \u0026quot;, coots = \u0026quot; \u0026lt;\u0026lt; coots \u0026lt;\u0026lt; endl;\r 2 auto声明(C++11) 让编译器能够根据初始值的类型推断变量的类型。 并不是为初始化声明而生的（这根本没必要），反而会让人误入歧途，只有处理复杂类型，如标准模块库（STL）中的类型时，自动推断类型的优势才能显现出来，例如：\n// C++98\rstd::vector\u0026lt;double\u0026gt; scores;\rstd::vector\u0026lt;double\u0026gt;::iterator pv = scores.begin();\r// C++11\rstd::vector\u0026lt;double\u0026gt; scores;\rauto pv = scores.begin();\r ","id":34,"section":"posts","summary":"1 强制类型转换 // typecast.cpp -- forcing type changes #include \u0026lt;iostream\u0026gt; int main() { using namespace std; int auks, bats, coots; auks = 19.99 + 11.99; bats = (int) 19.99 + (int) 11.99; // old C syntax coots = int (19.99) + int (11.99); // new C++ syntax cout \u0026lt;\u0026lt; \u0026quot;auks = \u0026quot; \u0026lt;\u0026lt; auks \u0026lt;\u0026lt; \u0026quot;, bats = \u0026quot; \u0026lt;\u0026lt; bats; cout \u0026lt;\u0026lt; \u0026quot;, coots","tags":null,"title":"cpp--chapter3--处理数据","uri":"https://hanin97.cn/2020/10/cpp-chapter3-%E5%A4%84%E7%90%86%E6%95%B0%E6%8D%AE/","year":"2020"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;—\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution  Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\n Blockquote with attribution  Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.— Rob Pike1 Tables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\n   Name Age     Bob 27   Alice 23    Inline Markdown within tables    Inline  Markdown  In  Table     italics bold strikethrough  code    Code Blocks Code block with backticks html\r\u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block indented with four spaces \u0026lt;!DOCTYPE html\u0026gt;\r\u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt;\r\u0026lt;head\u0026gt;\r\u0026lt;meta charset=\u0026quot;UTF-8\u0026quot;\u0026gt;\r\u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt;\r\u0026lt;/head\u0026gt;\r\u0026lt;body\u0026gt;\r\u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt;\r\u0026lt;/body\u0026gt;\r\u0026lt;/html\u0026gt;\r Code block with Hugo\u0026rsquo;s internal highlight shortcode \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;UTF-8\u0026#34;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; List Types Ordered List  First item Second item Third item  Unordered List  List item Another item And another item  Nested list  Item   First Sub-item Second Sub-item  Other Elements — abbr, sub, sup, kbd, mark GIFis a bitmap image format.\nH2O\nXn+ Yn= ZnPress CTRL+ALT+Deleteto end the session.\nMost salamandersare nocturnal, and hunt for insects, worms, and other small creatures.\n  The above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015. \u0026#x21a9;\u0026#xfe0e;\n  ","id":35,"section":"posts","summary":"\u003cp\u003eThis article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\u003c/p\u003e","tags":null,"title":"Markdown Syntax Guide","uri":"https://hanin97.cn/2019/03/markdown-syntax/","year":"2019"},{"content":"Lorem est tota propiore conpellat pectoribus de pectora summo.\nRedit teque digerit hominumque toris verebor lumina non cervice subde tollit usus habet Arctonque, furores quas nec ferunt. Quoque montibus nunc caluere tempus inhospita parcite confusaque translucet patri vestro qui optatis lumine cognoscere flos nubis! Fronde ipsamque patulos Dryopen deorum.\n Exierant elisi ambit vivere dedere Duce pollice Eris modo Spargitque ferrea quos palude  Rursus nulli murmur; hastile inridet ut ab gravi sententia! Nomine potitus silentia flumen, sustinet placuit petis in dilapsa erat sunt. Atria tractus malis.\n Comas hunc haec pietate fetum procerum dixit Post torum vates letum Tiresia Flumen querellas Arcanaque montibus omnes Quidem et  Vagus elidunt The Van de Graaf Canon\nMane refeci capiebant unda mulcebat Victa caducifer, malo vulnere contra dicere aurato, ludit regale, voca! Retorsit colit est profanae esse virescere furit nec; iaculi matertera et visa est, viribus. Divesque creatis, tecta novat collumque vulnus est, parvas. Faces illo pepulere tempus adest. Tendit flamma, ab opes virum sustinet, sidus sequendo urbis.\nIubar proles corpore raptos vero auctor imperium; sed et huic: manus caeli Lelegas tu lux. Verbis obstitit intus oblectamina fixis linguisque ausus sperare Echionides cornuaque tenent clausit possit. Omnia putatur. Praeteritae refert ausus; ferebant e primus lora nutat, vici quae mea ipse. Et iter nil spectatae vulnus haerentia iuste et exercebat, sui et.\nEurytus Hector, materna ipsumque ut Politen, nec, nate, ignari, vernum cohaesit sequitur. Vel mitis temploque vocatus, inque alis, oculos nomen non silvis corpore coniunx ne displicet illa. Crescunt non unus, vidit visa quantum inmiti flumina mortis facto sic: undique a alios vincula sunt iactata abdita! Suspenderat ego fuit tendit: luna, ante urbem Propoetides parte.\n","id":36,"section":"posts","summary":"\u003cp\u003eLorem est tota propiore conpellat pectoribus de\npectora summo.\u003c/p\u003e","tags":null,"title":"Placeholder Text","uri":"https://hanin97.cn/2019/03/placeholder-text/","year":"2019"},{"content":"Mathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\nIn this example we will be using KaTeX\n Create a partial under /layouts/partials/math.html Within this partial reference the Auto-render Extension or host these scripts locally. Include the partial in your templates like so:\n     To enable KaTex globally set the parameter math to true in a project's configuration To enable KaTex on a per page basis include the parameter math: true in content files.  Note: Use the online reference of Supported TeX Functions Examples Inline math: \\( \\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887… \\)\nBlock math:\n\\[ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } \\]\n","id":37,"section":"posts","summary":"\u003cp\u003eMathematical notation in a Hugo project can be enabled by using third party JavaScript libraries.\u003c/p\u003e","tags":null,"title":"Math Typesetting","uri":"https://hanin97.cn/2019/03/math-typesetting/","year":"2019"},{"content":"Emoji can be enabled in a Hugo project in a number of ways.\nThe emojify function can be called directly in templates or Inline Shortcodes.\nTo enable emoji globally, set enableEmoji to true in your site’s configuration and then you can type emoji shorthand codes directly in content files; e.g.\nThe Emoji cheat sheet is a useful reference for emoji shorthand codes.\n N.B. The above steps enable Unicode Standard emoji characters and sequences in Hugo, however the rendering of these glyphs depends on the browser and the platform. To style the emoji you can either use a third party emoji font or a font stack; e.g.\n.emoji { font-family: Apple Color Emoji,Segoe UI Emoji,NotoColorEmoji,Segoe UI Symbol,Android Emoji,EmojiSymbols; }","id":38,"section":"posts","summary":"\u003cp\u003eEmoji can be enabled in a Hugo project in a number of ways.\u003c/p\u003e","tags":null,"title":"Emoji Support","uri":"https://hanin97.cn/2019/03/emoji-support/","year":"2019"},{"content":" author: \u0026ldquo;Jineng Han\u0026rdquo; title: \u0026ldquo;数据结构与算法\u0026ndash;01概论\u0026rdquo; date: 2021-04-16T21:58:10+08:00 draft: false description: \u0026quot;\u0026quot; categories: [ \u0026ldquo;数据结构与算法\u0026rdquo;, ] series: [\u0026ldquo;Themes Guide\u0026rdquo;] aliases: [\u0026ldquo;migrate-from-jekyl\u0026rdquo;] @[TOC](1 概论)\n记：清华大学邓俊辉老师数据结构与算法视频学习笔记。\n1.0 知识点 5个问题：\n 什么是计算\u0026ndash;课程的目标 什么是好的计算\u0026ndash;评判DSA优劣的参照 度量DSA性能的尺度\u0026ndash;渐进复杂度，不需要太精细 怎么度量\u0026ndash;DSA性能度量的方法 DSA的设计及其优化  2个拓展：\n 理论模型与实际性能的差异 DSA优化的极限（下界）   1.1 计算 对象：规律、技巧 目标：高效、低耗\n1.1.1 例子 绳索计算机：垂线 尺规计算机：三等分，包含重复使用的子程序（做平行线）\n1.1.2 算法 输入：问题 输出：答案 正确性 确定性：由基本操作组成的序列 可行性：可实现，可在常数时间内完成 有穷性：对任何输入，经过有穷次基本操作，都可以得到输出\n1.1.3 有穷性 序列Hailstone 不能证明它是有穷的，也没有反例证明它是无穷的 写程序时经常写出死循环，栈溢出。1.1.4 好算法 ==正确：== 符合语法，能够编译、链接，能够处理简单的、大规模的、一般性的、退化的、任意合法的输入 健壮：能辨别不合法的输入并做适当处理，而不致非正常退出 可读： 结构化 + 准确命名 + 注释 ==效率：== 速度尽可能快，存储空间尽可能少\n Algorithms + Data Structures = Programs (Algorithms + Data Structures) x Efficiency = Computation\n  1.2 计算模型 正确性：不好数学证明 成本： 运行时间 + 所需存储空间\n特定算法 + 不同实例 如果用$T_A(P)$表示算法A求解问题实例P的计算成本，意义不大，因为可能出现的问题实例太多； 如果用$T_A(n)$表示算法A求解某一问题规模为n的实例所需的计算成本，仍然存在同一问题等规模的不同实例的计算成本不同（最好情况，最坏情况），应该首先考虑最坏情况；\n特定问题 + 不同算法 如果仅用实验统计，表面上很直接，但不足以准确反映算法的真正效率，因为算法的效率与输入规模、类型，使用的语言、编译器、体系结构、操作系统的状态有关； 所以需要抽象出一个理想的平台或模型：图灵机（Turing Machine）、Random Access Machine（RAM），一般计算工具的简化与抽象，独立于具体的平台，将算法的运行时间转换为算法需要执行的基本操作次数。\n 1.3 大O ==渐进分析：大O记号== $T(n)=O(f(n))， iff \\exists c \u0026gt; 0，当n \u0026raquo; 2时，有T(n) \u0026lt; cf(n)$ $\\sqrt{5n[3n(n+2)+4]+6} \u0026lt; \\sqrt{5n[6n^2+4]+6}\u0026lt; \\sqrt{35n^3+6}\u0026lt;6n^{1.5}=O(n^{1.5})$ 与$T_A(n)$相比，$f(n)$更简洁，f(n)的常系数可忽略，低次项可忽略。\n渐进分析：其他记号 最好情况（下界）：$T(n)=\\Omega(f(n))$ 中间情况：$T(n)=\\Theta(f(n))$\n==刻度==：\n $O(1)$：2 = 2013 = 2013 x 2013 = O(1) $logn$：常底数、常次幂、对数多项式都可以通过数学变换忽略掉 $O(n^c)$：多项式复杂度，只看最高次 $O(n)$：线性复杂度 $O(2^n)$：指数，通常认为不可忍受  一个指数复杂度的例子： S包含n个正整数，$\\sum{S}=2m$，S是否有子集T，满足$\\sum{T}=m$？ NP-complete问题\n 1.4 算法分析 去粗存精地估算 两个主要任务 = 正确性（不变性 x 单调性）+ 复杂度 在计算复杂度的时候，真的需要将算法描述为RAM的基本指令，再统计累计的执行次数吗？ 不必哦！只要渐进，在渐进的意义下，C++等高级语言的基本指令等效于常数条RAM的基本指令。\n主要方法：\n 迭代：级数求和 递归：递归跟踪 + 递推方程 猜测 + 验证   1.4.1 级数  算术级数：与末项平方同阶 $T(n)=1+2+3+\u0026hellip;+n=n(n+1)/2=O(n^2)$ 幂方级数：比幂次高出一阶（咋求的呀） $T_2(n)=1^2+2^2+3^2+\u0026hellip;+n^2=n(n+1)(2n+1)/6=O(n^3)$ $\\sum{_{k=0}^n} \\approx \\int{_0^nx^{d+1}dx}= \\frac{1}{d+1}x^{d+1}|_0^n=O(n^{d+1})$ 几何级数：与末项同阶 $T_a(n)=a^0+a^1+a^2+\u0026hellip;+a^n=(a^{n+1}-1)/(a-1)=O(a^n)$ 收敛级数 O(1) 调和级数 $h(n)=1+\\frac{1}{2}+\\frac{1}{3}+\u0026hellip;+\\frac{1}{n}=\\Theta(logn)$ 对数级数 $log1+log2+log3+\u0026hellip;+logn=log(n!)=\\Theta(nlogn)$   1.4.2 循环 vs. 级数 可以用画图的方法帮助计算\n  算术级数$\\sum{_{i=0}^{n-1}}n = n+n+n+\u0026hellip;+n=O(n^2)$ for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; n; j++) O1Operation(i, j);     算术级数$\\sum{_{i=0}^{n-1}}i = 0+1+2+\u0026hellip;+(n-1)=\\frac{n(n-1)}{2}=O(n^2)$ for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; i; j++) O1Operation(i, j);     几何级数$1+2+4+\u0026hellip;+2^{log_2(n-1)}=O(n)$ for (int i = 0; i \u0026lt; n; i \u0026lt;\u0026lt;= 1) for (int j = 0; j \u0026lt; i; j++) O1Operation(i, j);     几何级数$0+0+1+22+34+48+\u0026hellip;=\\sum{_{k=0\u0026hellip;logn}(k2^{k-1})}=O(logn*2^{logn})=nlogn$ $\\sum{_{k=0}^n}\\lceil log_2k \\rceil=O(nlogn)$ for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; i; j += j) O1Operation(i, j);      1.4.3 取非极端元素 给定整数子集S，|S| \u0026gt;= 3，找出其中既不是最大值，又不是最小值的元素。 常数时间复杂度\n1.4.4 冒泡排序 初始版本\n// 外循环的终止条件是啥？没错，就是sotred，赋值的同时也充当判断条件 void bubblesort(int A[], int n) { for (bool sorted = false; sorted = !sorted; n--) for (int i = 1; i \u0026lt; n; i++) if (A[n-1] \u0026gt; A[i]) { swap(A[i-1], A[i]); sorted = false; } }  分析： 不变性：经k轮扫描交换后，最大的k个元素必然就位 单调性：经k轮扫描交换后，问题规模缩减至n-k 正确性：经至多n趟扫描惠普，算法必然终止，且能给出正确解答\n1.4.5 封底估算（Back-of-the-Envelope）  1.5 迭代与递归  迭代乃人工，递归方神通 但是递归的效率通常不是最佳的，迭代体现出更强的优势\n 1.5.1 数组求和：迭代 int sumI(int A[], int n) { int sum = 0;\t// O(1) for (int i = 0; i \u0026lt; n; i++)\t// O(n) sum += A[i];\t// O(1) return sum;\t// O(1) }  分析：\n 时间复杂度：O(n)，空间复杂度（除输入本身）：O(2) 每循环一次，规模缩小1 引出减而治之\n 1.5.2 数组求和：线性递归（减而治之） sum(int A[], int n) { return (n \u0026lt; 1) ? 0 : sum(A, n-1) + A[n-1]; //\t缩减问题 + 平凡问题：可直接求解 }  递归跟踪分析：\n 时间复杂度：O(n)，所有递归实例时间的总和，缩减问题的时间并入子问题\n 递推方程分析：\n T(n) = T(n-1) + O(1) T(0) = O(1) 求解： T(n) - n = T(n-1) - (n-1) = \u0026hellip; = T(2) - T(1) = T(1) - 1 = T(0)\n 1.5.3 数组倒置（减而治之） // 递归版 void reverse(int* A, int low, int high) { // 问题规模的奇偶性不变，因为每次变化2，那最后的情况有两种： // 剩最小的奇数1，最小的偶数0，需要两个递归基，low==high，不用变，low \u0026gt; high，不用变 if (low \u0026lt; high) { swap(A[low], A[high]);\t// 平凡问题 reverse(A, low+1, high-1);\t// 缩减问题 } } // 迭代原始版 next: if (low \u0026lt; high) { swap(A[low], A[high]); low++; high--; goto next; } // 迭代精简版 while (low \u0026lt; high) swap(A[low++], A[high--]);  1.5.4 分而治之 将大规模问题划分为若干个子问题（通常两个），规模大体相当，合并子问题的解。 数组求和：二分递归\nsum (int A[], int lo, int hi) { if (lo == hi) return A[lo];\t// 递归基 int mi = (lo + hi) \u0026gt;\u0026gt; 2; return sum(A, lo, mi) + sum(A, mi + 1, hi); }  递归跟踪分析：\n 所有递归实例时间总和（去掉递归调用本身的时间去掉） $T(n)=O(1) * (2^0, 2^1, 2^2, + \u0026hellip; + 2^{logn})=O(1) * (2^{logn+1}-1)=O(n)$ 几何级数的总和与末项同阶 递推方程分析：\n 递推基：sum(A, lo, lo) $T(0)=2T(n/2)+O(1)$，O(1)为归并时间 $T(1)=1$，为什么这里不是T(0)?因为递推基的规模为1呀$$ T(n) = 2T(n/2) + c_1 \\\nT(n) + c_1 = 2(T(n/2)+c_1)=2^2*(T(n/4)+c_1) =\u0026hellip; =2^{logn}(T(1)+c_1) =2nc_1\\\n=\u0026gt;T(n)=O(n) $$\n 1.5.5 Max2 找出数组中最大的两个元素，比较次数尽可能少\n迭代1，比较2n-3次\nvoid max2(int A[], int lo, int hi, int \u0026amp; x1, int \u0026amp; x2) { for (x1 = lo, int i = lo + 1; i \u0026lt; hi; i++) if A[x1] \u0026lt; A[i] x1 = i; for (x2 = lo, int i = lo + 1; i \u0026lt; x1; i++) if A[x2] \u0026lt; A[i] x2 = i; for (int i = x1 + 1; i \u0026lt; hi; i++) if A[x2] \u0026lt; A[i] x2 = i; }  迭代2，双指针，妙啊，比较次数：最好n-1，最坏2n-3\nvoid max(int A[], int lo, int hi, int \u0026amp; x1, int \u0026amp; x2) { if (A[x1 = lo] \u0026lt; A[x2 = lo + 1]) swap(x1, x2); for (int i = lo + 2; i \u0026lt; hi; i++) if (A[x2] \u0026lt; A[i]) if (A[x1] \u0026lt; A[x2 = i]) swap(x1, x2); }  递归 + 分治\nvoid max2(int A[], int lo, int hi, int \u0026amp; x1, int \u0026amp; x2) { if (lo + 2 == hi) x1 = (A[lo] \u0026gt; A[lo + 1]) ? A[lo] : A[lo + 1]; if (lo + 3 == hi) { if (A[lo] \u0026gt; A[lo + 1]) { if (A[lo + 1] \u0026gt; A[lo + 2]) { x1 = A[lo]; x1 = A[lo + 1]; } else { if (A[lo] \u0026gt; A[lo + 2]) { x1 = A[lo]; x2 = A[lo + 2]; } else {x1 = A[lo + 2]; x2 = A[lo];} } else { if (A[lo] \u0026gt; A[lo + 2]) { x1 = A[lo + 1]; x2 = A[lo]; } else { if (A[lo + 1] \u0026gt; A[lo + 2]) { x1 = A[lo + 1]; x2 = A[lo + 2]; } else {x1 = A[lo + 2]; x2 = A[lo + 1];} } } } } int mi = (lo + hi) / 2; int x1L, x2L; max2(A, lo, mi, x1L, x2L); int x2R, x2Rl max2(A, mi, hi, x1R, x2R); if (A[x1L] \u0026gt; A[x1R]) { x1 = x1L; x2 = (A[x2L] \u0026gt; A[x1R]) ? x2L : x1R; } else { x1 = x1R; x2 = (A[x1L] \u0026gt; A[x2R]) ? x1L : x2R; } }  分析：\n 递推基：问题规模的奇偶性不变，两个递推基：\n 大于等于2的最小偶数，2，（为什么要大于2呢？因为要求解两个数呀） 大于等于2的最小奇数，3  最差情况剩两组大小为3的数组： $T(n) + 2 = 2(T(n/2)+2)\u0026lt;=2^{log(n/3)}(T(3)+2)=5n/3=\u0026gt;T(n)=5n/3-2$\n  1.6 动态规划 通过递归找出算法的本质，给出初步解，再将其转化为等效的迭代形式。\n1.6.1 FIB fib()：递归 $fib(n)=fib(n-1)+fib(n-2):{0, 1, 1, 2, 3, 5, 8, \u0026hellip;}$\nint fib(n) { return (n \u0026lt; 2) ? n : fib(n-1) + fib(n-2); }  当n稍微大点（如64）时，运行速度很慢，为什么呢？直觉上看，它是将一个规模大的问题分解成两个规模小的子问题，这两个子问题有交集，其中一个子问题是另一个问题的子问题。递推方程分析：\n 递推基：$T(0) = T(1) = 1;$ 方程：$T(n) = T(n-1) + T(n-2) + 1$ 求解：令$S(n)=[T(n)+1]/2$，则$S(0)=1=fib(1),S(1)=1=fib(2)$ 故$S(n)=S(n-1)+S(n-2)=fib(n+1)$， $T(n)=2S(n)-1=2fib(n+1)-1=O(fib(n+1))=O(\\Phi^n)=O(2^n)$\n 封底估算：\n $\\Phi^{36}=2^{25}, \\Phi^{43}=2^{30}={10^3}^3=10^9flo=1sec$ $\\Phi^{5}=10,\\Phi^{67}=10^{14}flo=10^5sec=1day$\n 递归跟踪：\n 有大量重复的递归实例，能不能每个实例只计算一次？类比：爬楼梯，每次只能爬1、2阶，到第6阶有几种走法？\n fib()回归迭代\n 记忆法：将已计算过的实例的结果制表备查 动态规划 颠倒计算方向，由自顶向下递归变为自底向上迭代 两个变量记录当前相邻的两个数，滚动向前 f = 0; g = 1; while (0 \u0026lt; n--) { g = g + f; f = g - f; } return g;  ``\n  1.6.2 最长公共子序列LCS LCS：递归 A[0, n]; B[0, m] 递归基：n = -1 or m = -1, LCS is \u0026quot;\u0026quot;\nif (A[n] == A[m] == 'X') LCS(A[0, n], B[0, m]) = LCS(A[0, n), B[0, m)) + 'X'; // 减而治之 else LCS = max(LCS(A[0, n), B[0, m]), LCS(A[0, n], B[0, m)) // 分而治之  分析：\n 同一个递归实例会被多次唤醒，但实例个数共n+m，其实只需要计算n+m次\n 改进： 颠倒计算方向，从LCS(A[0], B[0])出发依次计算出所有项\nvertor\u0026lt;char\u0026gt; vecA, vecB; int length[n+1][m+1] = {0}; for (int i = 0; i \u0026lt; n; i++) vecA.push_bask(A[i]); for (int i = 0; i \u0026lt; m; i++) vecA.push_bask(B[i]); for (int i = 0; i \u0026lt; n; i++) for (int j = 0; j \u0026lt; m; j++) { if (vecA.at(i) == vecB.at(j)) length[i+1][j+1] = length[i][j] + 1; else length[i+1][j+1] = max(length[i][j+1], length[i+1][j]); }  ","id":39,"section":"posts","summary":"author: \u0026ldquo;Jineng Han\u0026rdquo; title: \u0026ldquo;数据结构与算法\u0026ndash;01概论\u0026rdquo; date: 2021-04-16T21:58:10+08:00 draft: false description: \u0026quot;\u0026quot; categories: [ \u0026ldquo;数据结构与算法\u0026rdquo;, ] series: [\u0026ldquo;Themes Guide\u0026rdquo;]","tags":null,"title":"","uri":"https://hanin97.cn/1/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95-01%E6%A6%82%E8%AE%BA/","year":"0001"}],"tags":[{"title":"Breast cancer","uri":"https://hanin97.cn/tags/breast-cancer/"},{"title":"classification network","uri":"https://hanin97.cn/tags/classification-network/"},{"title":"Colorectal cancer","uri":"https://hanin97.cn/tags/colorectal-cancer/"},{"title":"computational pathology","uri":"https://hanin97.cn/tags/computational-pathology/"},{"title":"computer vision","uri":"https://hanin97.cn/tags/computer-vision/"},{"title":"domain adaptation","uri":"https://hanin97.cn/tags/domain-adaptation/"},{"title":"GNN","uri":"https://hanin97.cn/tags/gnn/"},{"title":"prostate cancer","uri":"https://hanin97.cn/tags/prostate-cancer/"}]}